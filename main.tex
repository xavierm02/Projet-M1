\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{float}
\newtheorem {mydef} {D\'efinition}
\newcommand{\enum}[2]{\llbracket #1, #2 \rrbracket}
\begin{document}

    \title{Diagnosability}

    \author{François Godi, Xavier Montillet, Chen Qian}

\section{Pr\'erequis}

\subsection{Automates}

Un automate fini non déterministe (avec $\varepsilon$-transitions) est un 5-uplet
$$A = (Q, \Sigma, \Delta, q_0, F)$$
o\`u
\begin{itemize}
	\item $Q$ est l'ensemble fini des états du système.
	\item $\Sigma$ est l'ensemble des événements.
	\item $\Delta \subseteq (Q \times (\Sigma \cup \{\varepsilon\}) \times Q)$ est une relation de transition.
	\item $q_0 \in Q$ l'états initial.
	\item $F$ l'ensemble des \'etats finaux.
\end{itemize}

\'Etant donn\'es $p,q \in Q$ et $l\in \Sigma \cup \{\varepsilon\}$, on notera $p \overset{l}{\underset{\Delta}{\to}}q$ pour $(p,l,q) \in \Delta$.

On notera \'egalement $q_0 \overset{l_0}{\underset{\Delta}{\to}} \dots \overset{l_n}{\underset{\Delta}{\to}} q_{n+1}$ pour $\forall k \in \enum{0}{n}, q_k \overset{l_k}{\underset{\Delta}{\to}} q_{k+1}$.



Un automate fini non d\'eterministe sans $\varepsilon$-transitions est un automate fini non d\'eterministe tel que $\Delta \subseteq (Q\times \Sigma \times Q)$.

Un automate fini d\'eterministe est un automate fini non-d\'eterministe sans $\varepsilon$-transitions tel que $\Delta$ peut \^etre vue comme une fonction de $Q\times \Sigma$ dans $Q$: $\forall p,q,q' \in Q, \forall l \in \Sigma, p\overset{l}{\underset{\Delta}{\to}}q \land p\overset{l}{\underset{\Delta}{\to}}q' \implies q=q'$

\subsection{Langage reconnu}

Le langage $L(A)$ reconnu par un automate $A$ est d\'efini par... TODO


\subsection{Produit synchrone}

Soit $A = (Q, \Sigma, \Delta, q_0, F)$ et $A' = (Q', \Sigma, \Delta', q_0', F')$. On définit le produit synchrone de ces automates comme \'etant $$A\times A' = (Q \times Q', \Sigma, \Delta'', (q_0, q_0'), F\times F')$$ o\`u $\Delta''$ est d\'efinie par $(p,p')\overset{l}{\underset{\Delta''}{\to}}(q,q') \iff p\overset{l}{\underset{\Delta}{\to}}q \land p'\overset{l}{\underset{\Delta'}{\to}}q'$.

On notera que $L(A\times B) = L(A) \cap L(B)$.

\subsection{$\varepsilon$-clôture}

On définit  $\operatorname{cl}_\varepsilon(A) = (Q, \Sigma, \Delta', q_0, F)$, l'$\varepsilon$-clôture \`a gauche de l'automate $A$.

$\Delta'$ est d\'efinie par $p \overset{l}{\underset{\Delta'}{\to}} r \iff \exists q_1,\dots,q_n \in Q, p \overset{\varepsilon}{\underset{\Delta}{\to}} q_1 \overset{\varepsilon}{\underset{\Delta}{\to}} \dots \overset{\varepsilon}{\underset{\Delta}{\to}} q_n \overset{l}{\underset{\Delta}{\to}} r$.

On notera que $L(\operatorname{cl}_\varepsilon(A))=L(A)$.

On d\'efinit le langage $L(A)$ reconnu par un automate $A$ comme ... TODO?

\subsection{Projection}
TODO automate correspondant

Soit $\Sigma'\subseteq \Sigma$. On d\'efinit la projection $P_{\Sigma \to \Sigma'}$ de $\Sigma^*$ dans $\Sigma'^*$ comme \'etant l'unique fonction v\'erifiant:

$$P_{\Sigma \to \Sigma'}(\varepsilon) = \varepsilon$$
$$\forall a \in \Sigma, P_{\Sigma \to \Sigma'}(a)=\left\{\begin{array}{ll}
a &\text{if } a\in \Sigma'\\
\varepsilon &\text{if } a\not\in \Sigma'\\
\end{array}\right.$$
$$\forall a \in \Sigma, \forall u \in \Sigma^+, P_{\Sigma \to \Sigma'}(au)=P_{\Sigma \to \Sigma'}(a)P_{\Sigma \to \Sigma'}(u)$$

\section{Diagnosticabilit\'e}

Diagnostiquer un syst\`eme, c'est d\'etecter s'il a fait une faute en un temps born\'e apr\`es la faute. On formalise cette notion de la fa\c{c}on suivante :
\begin{itemize}
	\item On se donne un alphabet $\Sigma=\Sigma_o\sqcup\Sigma_f$ o\`u $\Sigma_o$ est l'ensemble des \'ev\`enements observables et $\Sigma_f$ et l'ensemble des \'ev\`enements fautifs
	\item On repr\'esente le syst\`eme par un automate $\mathcal F$
	\item On repr\'esente le mod\`ele de faute par un langage r\'egulier $L$
	\item 
\end{itemize}

Lorsque un mot est généré par l'automate, à chaque transition, on peut observer l’événement de la transition si et seulement si cet événement est observable. Étant donné que :
\begin{enumerate}
\item Un événement fautif observable est trivialement diagnosticable.
\item Les transitions du système dont l'événement est non fautif et non observable peuvent déjà être modélisées par des $\varepsilon$-transitions.
\end{enumerate} 
On peut considérer sans perte de généralité que les observables sont les événements non fautifs, on note $\Sigma_0 = \Sigma \setminus \{f\}$ cet ensemble d'observables.
\paragraph{}
Soit $u \in \Sigma^*$, on note $l(u)$ sa longueur. On dit que $G$ est diagnosticable si pour tout mot $u$ généré par $G$, il existe $n \in \mathbb{N}$ tel que il suffit de connaître les $l(P(u)) + n$ premières lettres de $P(u)$ pour savoir si f est l'une des lettres de $u$. Soit $I \subset \Sigma$, on dit que $G$ est I-diagnosticable si pour tout mot $u$ généré par $G$ et se terminant par $\sigma \in I$, il existe $n \in \mathbb{N}$ tel que il suffit de connaître les $l(P(u)) + n$ premières lettres de $P(u)$ pour savoir si f est l'une des lettres de $u$.
Le système que l'on cherche à diagnostiqueur est modélisé par un automate fini non d\'eterministe avec $\varepsilon$-transitions tel que $F=Q$ et $f\in \Sigma$.


\section{R\'eductions}

\subsection{I-diagnosticabilit\'e}

TODO

\subsection{Vivant}

TODO

\section{Algorithme de construction du diagnostiqueur}
    Nous allons présenter un algorithme pour construire un diagnostiqueur en temps exponentiel.
        \subsection{Quelques notions}
   \begin{mydef}{Automate de mod\`ele de faute : }
                Un automate adapté au modèle de faute que l'on cherche à diagnostiquer. Plus formellement, nous posons un automate $MF = (\Sigma = \Sigma_n \bigsqcup \Sigma_f \bigsqcup \Sigma_r, Q = Q_n \bigsqcup Q_f,q_0,\Delta, F)$,  $Q_n$ est l'ensemble des <<\'etats normaux>> et $Q_f$ l'ensemble des <<\'etats fautifs>>, $\Sigma_n$  l'ensemble des <<\'ev\`enements normaux>>, $\Sigma_f$ l'ensemble des  <<\'ev\`enements fautifs>> et $\Sigma_r$ l'ensemble des <<\'ev\`enements r\'eparatifs>>. $MF$ respecte les propri\'et\'es suivantes, si nous avons une transition a$\xrightarrow{x}$b:
                \begin{center}
                \begin{tabular}{|c|c|c|}
                        \hline
                        & $a\in Q_n$ & $a\in Q_f$\\
                        \hline                        
                        $x\in \Sigma_n$ & $b\in \Sigma_n$&$b\in \Sigma_f$\\
                        \hline                        
                        $x\in \Sigma_f$ &$b\in \Sigma_f$&$b\in \Sigma_f$\\
                        \hline
                        $x\in \Sigma_r$ & $b\in \Sigma_n$ & $b \in \Sigma_n$\\
                        \hline
                \end{tabular}
                \end{center}
    \end{mydef}
    
    \paragraph{Exemple (automate des mod\`ele de fautes): } %Il faudrait ajouter les états initiaux (mais je ne sais pas comment faire)
    
    Dans les automates suivants, $ \Sigma_f  = \{f\}$, $ \Sigma_r  = \{r\}$, les  nœuds blancs sont les états normaux et les nœuds gris sont les \'etats fautifs. 
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1)->(2) node[midway,above]{$f$};
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$\Sigma^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de fautes permanentas}
        \end{figure}
        
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1) to[bend right=30] node[pos=0.5,below]{$f$}(2);
                        \draw[->,>=latex] (2) to[bend right=30] node[pos=0.5,above]{$r$}(1);
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$(\Sigma\backslash \{ r \})^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de fautes avec r\'eparations} 
    \end{figure}
            
    
    \subsection{Construction du diagnostiqueur}
    Pour construire les diagnostiqueurs de l'automate $A$ avec l'automate de mod\`ele de faute $MF$. Nous allons proc\'eder de la mani\`ere suivante :
    
    \begin{enumerate}
            \item Faire le  produit de l'automate $A$ avec l'automate $MF$. Un \'etat de $A\times MF$ est appel\'e un \'etat fautif si et seulement si c'est un produit d'un \'etat fautif de $MF$ avec un autre \'etat de $A$
            \item Remplacer les \'ev\`enements fautifs par des $\varepsilon$-transitions et faire l'$\epsilon$-cl\^oture, $C = \varepsilon$-clôture$((A\times MF)[\varepsilon/f])$.
          \item D\'eterminiser l'automate $C$, on note $D$ l'automate d\'eterminis\'e.
            \item Nous discriminons les diff\'erents \'etats de $D$ :
                    \begin{itemize}
                            \item  \'Etats normaux: Tous les \'etats correspondants à un ensemble d'\'etats non-fautifs.
                           \item \'Etats fautifs:  Tous les \'etats correspondants à un ensemble d'\'etats fautifs.
                            \item \'Etats de doute: Tous les \'etats correspondants à un ensemble composé à la fois d'\'etats fautifs et non-fautifs.
                    \end{itemize}  
                      L'intuition de cette appellation est la suivante : 
                    \begin{itemize}
                    \item Si nous arrivons dans un \'etat normal nous sommes s\^ur qu'aucun \'ev\`enenement fautif ne s'est produit dans notre syst\`eme. 
    \item Si nous arrivons dans un \'etat fautif nous sommes s\^ur qu'un \'ev\`enenement fautif s'est produit dans notre syst\`eme. 
            \item Si nous arrivons dans un \'etat de doute, nous ne pouvons pas d\'eterminer si \'ev\`enement fautif s'est produit.
\end{itemize}
    \end{enumerate} 
    \subsection{D\'eterminer les \'ev\`enements fautifs}
        Une fois que nous avons construit le diagnostiqueur $D$ de l'automate $A$ avec le mod\`ele de faute $MF$, l'article de Meera Sampath et Kasim Sinnamohideen propose de regarder les deux ensembles suivants :
        \begin{itemize}
             \item Ensemble $\mathcal{N} = $ tous les mots accept\'es par les \'etats normaux.  % "ou un cycle.." peu clair
             \item Ensemble $\mathcal{F} = $ tous les mots accept\'es par les \'etats fautifs. %idem
        \end{itemize}
    Nous pouvons dire que le syst\`eme est non-diagnosticable si et seulement si $\mathcal{N}\cap \mathcal{F}$ ne contient pas  mots infinis.% Pas de projection ?? 

\section{D\'ecision de la diagnosticabilit\'e en temps polynomial}

Soit $\mathcal A$ un automate fini non-d\'eterministe avec $\varepsilon$-transitions et $\mathcal F$ un . un langage r\'egulier suffixe-clos TODO.

L'id\'ee de l'agorithme est qu'un automate est diagnosticable par rapport a un mod\`ele de fautes si et seulement si il existe des mots observable a la fois quand une faute a eu lieu et quand aucune faut n'a eu lieu de taille arbitraire. Le langage $\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F)$ est le langage des observations avec fautes. Le langage $\pi_{\Sigma_o}(\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F))$ est le langage est observations des ex\'ecutions avec faute. Le langage $\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F)$ est le langage des ex\'ecutions sans faute. Le langage $\pi_{\Sigma_o}(\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F))$ est le langage des observations d'ex\'ecutions sans faute. Donc $\pi_{\Sigma_o}(\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F)) \cap \pi_{\Sigma_o}(\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F))$ est le langage des observations ambigues. Il suffit donc de v\'erifier que ce langage ne contient que des mots de taille born\'ee, ce qui est equivalent au fait qu'il soit fini, ce qui est \'equivalent \`a l'abscence de cycle accessible dans l'automate le repr\'esentant. Or on sait construire un automate de taille $|\mathcal F|^2 \times |\mathcal A|^2$ reconnaissant ce langage et la d\'etection de cycle accessible peut se faire en temps lin\'eaire. On dispose donc d'un algorithme en $|\mathcal F|^2 \times |\mathcal A|^2$ pour d\'ecider si un automate est diagnosticable par rapport \`a un mod\`ele de fautes.

Note : La longueur du mot le plus long dans ce langage est la dur\'ee maximale pendant laquelle on ne sait pas si le syst\`eme a fait une faute ou non.

\end{document}
