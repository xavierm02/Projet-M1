\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{float}
\newtheorem{mydef}{D\'efinition}
\newtheorem{myth}{Th\'eor\`eme}
\newcommand{\enum}[2]{\llbracket #1, #2 \rrbracket}
\usetikzlibrary{arrows}
\bibliographystyle{plain}

\begin{document}


    \title{Bibliographie sur l'opacit\'e}

    \author{François Godi, Xavier Montillet, Chen Qian}

\maketitle

\begin{abstract}
TODO
\end{abstract}

\section*{Introduction}

De nos jours, les syst\`emes d'information ont tendance \`a \^etre trop complexes pour que l'on puisse se convaincre de leur suret\'e. On les mod\'elise donc par des automates afin d'en prouver certaines propri\'et\'es. Ce rapport d\'ecrit les propri\'et\'es de diagnosticabilit\'e qui expriment la capacit\'e \`a d\'etecter les fautes du syst\`eme \`a partire d'une information partielle sur son \'etat, les propri\'et\'es de non-interf\'erence qui mod\'elisent le fait que les actions de certains utilisateurs du syst\`eme sont cach\'ees aux autres, et les propri\'et\'es d'opacit\'e qui permettent d'unifier les deux notions pr\'ec\'edentes.

\section{Pr\'erequis}

\subsection{Automates}

Un automate fini (avec $\varepsilon$-transitions) est un 5-uplet $A = (Q, \Sigma, \Delta, q_0, F)$ o\`u
\begin{itemize}
	\item $Q$ est l'ensemble fini des états du système.
	\item $\Sigma$ est l'ensemble des événements.
	\item $\Delta \subseteq (Q \times (\Sigma \cup \{\varepsilon\}) \times Q)$ est une relation de transition.
	\item $q_0 \in Q$ l'état initial.
	\item $F$ l'ensemble des \'etats finaux.
\end{itemize}

\'Etant donn\'es $p,q \in Q$ et $l\in \Sigma \cup \{\varepsilon\}$, on notera $p \underset{\Delta}{\overset{l}{{\to}}}q$ pour $(p,l,q) \in \Delta$. On notera \'egalement $q_0 \underset{\Delta}{\overset{l_0}{{\to}}} \dots \underset{\Delta}{\overset{l_n}{{\to}}} q_{n+1}$ pour $\forall k \in \enum{0}{n}, q_k 
\underset{\Delta}{\overset{l_k}{{\to}}} q_{k+1}$. Pour simplifier, le $\Delta$ sera omis lorsqu'il est \'evident.



On dit qu'un automate fini est sans $\varepsilon$-transitions si $\Delta \subseteq (Q\times \Sigma \times Q)$.

Un automate fini d\'eterministe est un automate fini sans $\varepsilon$-transitions tel que $\Delta$ peut \^etre vue comme une fonction de $Q\times \Sigma$ dans $Q$: $\forall p,q,q' \in Q, \forall l \in \Sigma, p\overset{l}{{\to}}q \land p\overset{l}{{\to}}q' \implies q=q'$

\subsection{Langage reconnu}

Un mot $l_1...l_n \in \Sigma^*$ est reconnu par un automate $A$ si il existe $n \in \mathbb N$ et $q_1,...,q_n \in Q$ tel que $q_0 \overset{l_1}{{\to}} q_1 \overset{l_2}{{\to}} \dots \overset{l_n}{{\to}} q_{n+1}$ et $q_{n+1} \in F$.

Le langage $L(A)$ reconnu par un automate $A$ est l'ensemble des mots de $\Sigma^*$ reconnus par $A$.

\subsection{Produit synchrone}

Soient $A = (Q, \Sigma, \Delta, q_0, F)$ et $A' = (Q', \Sigma', \Delta', q_0', F')$ deux automates sans $\varepsilon$. On définit le produit synchrone de ces automates comme \'etant $$A\times A' = (Q \times Q', \Sigma \cap \Sigma', \Delta'', (q_0, q_0'), F\times F')$$ o\`u $\Delta''$ est d\'efinie par $(p,p')\overset{l}{{\to}}(q,q')$ si et seulement si $p\overset{l}{{\to}}q$ et $p'\overset{l}{{\to}}q'$.

On notera que $L(A\times B) = L(A) \cap L(B)$.

\subsection{$\varepsilon$-clôture}

On définit  $\operatorname{cl}_\varepsilon(A) = (Q, \Sigma, \Delta', q_0, F)$ comme l'$\varepsilon$-clôture \`a gauche de l'automate $A$, c'est-\`a-dire $p \underset{\Delta'}{\overset{l}{{\to}}} r$ si et seulement si il existe $n\ge 1$ et $q_1,\dots,q_n \in Q,$ tels que $q_1 \underset{\Delta}{\overset{\varepsilon}{{\to}}} \dots \underset{\Delta}{\overset{\varepsilon}{{\to}}} q_n \underset{\Delta}{\overset{l}{{\to}}} r$.

On notera que $L(\operatorname{cl}_\varepsilon(A))=L(A)$.

\subsection{Projection}
%TODO automate correspondant

Soit $\Sigma'\subseteq \Sigma$. On d\'efinit la projection $\pi_{\Sigma'}$ de $\Sigma^*$ dans $\Sigma'^*$ comme \'etant l'unique fonction v\'erifiant:

$$\forall u,v \in \Sigma^*, \pi_{\Sigma'}(uv)=\pi_{\Sigma'}(u)\pi_{\Sigma'}(v)$$
$$\pi_{\Sigma'}(\varepsilon)=\varepsilon$$

$$\forall a\in \Sigma,\pi_{\Sigma'}(a)=\left\{\begin{array}{ll}
a &\text{si } a\in \Sigma'\\
\varepsilon &\text{sinon} \\
\end{array}\right.$$

\section{Diagnosticabilit\'e}

\'Etant donn\'e un langage $L$ extension-clos appel\'e mod\`ele de faute (repr\'esent\'e par un automate fini d\'eterministe), un automate $A$ appel\'e syst\`eme et une partition $\Sigma=\Sigma_o\sqcup \Sigma_{no}$. On appelera les \'el\'ements de $\Sigma$ des \'ev\`enements et on dira qu'un \'ev\`enement est observable (resp. non-observable) s'il est dans $\Sigma_o$ (resp. $\Sigma_{no}$).

TODO On dit que le système $\mathcal F$ est diagnosticable si et seulement si $\exists n \in \mathbb N, \forall  f \in L, \forall w \in \Sigma^*$ tel que $|\pi_{\Sigma_o}(w)| \geq n, \forall u \in \Sigma^* f w$, on peut savoir que $f$ est un sous mot de $u$ en observant $|\pi_{\Sigma_o}(u)$.~\cite{SamSRST96} 


\section{R\'eductions}

\subsection{I-diagnosticabilit\'e}


Soit $I \subset \Sigma$, On dit que le système $\mathcal F$ est I-diagnosticable si et seulement si $\exists n, \forall  f \in L, \forall w \in \Sigma^*$ tel que $|\pi_{\Sigma_o}(w)| \geq n, \forall u \in \Sigma^*f \Sigma^* I w$, on peut savoir que f est un sous mot de $u$ en observant $|\pi_{\Sigma_o}(u)$. 


Cela revient à étudier la diagnosticabilité avec le langage de fautes $L'=L \Sigma^* I$.

%\subsection{Vivant}

%TODO

\section{Algorithme de construction d'un diagnostiqueur}
    Nous allons présenter un algorithme pour construire un diagnostiqueur en temps exponentiel. ~\cite{SamSRST96}
        \subsection{Automate de mod\`ele de faute}
   \begin{mydef}{Automate de mod\`ele de faute : }
C'est un automate qui reconnait le langage de faute L. Les états finaux de l'automate de faute sont appelés <<\'etats fautifs>> et les autres <<\'etats normaux>>.
 \end{mydef}
    
    \paragraph{Exemple (automate de mod\`ele de faute): } %Il faudrait ajouter les états initiaux (mais je ne sais pas comment faire)
    
   Dans la figure 1 [TODO vraie ref] $f\in \Sigma$ et $L  = \Sigma^*\{f\}\Sigma^*$. Les  nœuds blancs sont les états normaux et les nœuds gris sont les \'etats fautifs. Avec ce mod\`ele de faute, une ex\'ecution est fautive si est seulement si $f$ s'est produit.
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1)->(2) node[midway,above]{$f$};
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$\Sigma^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de faute simple}
        \end{figure}
        
    
    \subsection{Construction d'un diagnostiqueur}
    Pour construire un diagnostiqueur de l'automate $A$ avec l'automate de mod\`ele de faute $L$, on proc\'ede de la mani\`ere suivante :
    
\begin{enumerate}
  \item Construire $B=A\times F$, le produit synchrone de $B$ et $F$.
  \item Construire $C=\operatorname{cl}_\varepsilon(B[\varepsilon/no])$ (TODO definir proprement $[\varepsilon/no]$)
  \item Construire $D=\det(C)$ le d\'eterminis\'e de $C$. Un \'etat $q\subseteq Q$ de $D$ est l'ensemble des \'etats dans lesquels on pourrait se trouver si on avait lu le m\^eme mot dans $C$. On distinguera trois cas :
  \begin{itemize}
    \item Si tous les \'etats dans $q\subseteq Q$ sont non-fautifs, on dira que $q$ est normal.
    \item Si tous les \'etats dans $q\subseteq Q$ sont fautifs, on dira que $q$ est fautif.
    \item Si $q\subseteq Q$ contient des \'etats fautifs et des \'etats non-fautifs, on dira que $q$ est un \'etat de doute.
  \end{itemize}
\end{enumerate} 
     

\section{D\'ecision de la diagnosticabilit\'e en temps polynomial}

L'id\'ee de l'agorithme est qu'un automate est diagnosticable par rapport \`a un mod\`ele de fautes si et seulement si aucun mot infini contenant une faut n'est ambigu.

\begin{enumerate} 
  \item $\mathcal L (A) \cap \mathcal L(L)$ est le langage des ex\'ecutions avec fautes.
  \item $\pi_{\Sigma_o}(\mathcal L (A) \cap \mathcal L(L))$ est le langage des observations d'ex\'ecutions avec faute.
  \item $\mathcal L(A) \setminus \mathcal L(L)$ est le langage des ex\'ecutions sans faute.
  \item $\pi_{\Sigma_o}(\mathcal L(A) \setminus \mathcal L(L))$ est le langage des observations d'ex\'ecutions sans faute.
  \item Donc $\pi_{\Sigma_o}(\mathcal L(A) \setminus \mathcal L(L)) \cap \pi_{\Sigma_o}(\mathcal L (A) \cap \mathcal L(L))$ est le langage des observations d'ex\'ecutions ambiguës.
\end{enumerate}
Il suffit donc de v\'erifier que ce langage ne contient que des mots de taille born\'ee, ce qui est équivalent au fait qu'il soit fini, ce qui est \'equivalent \`a l'absence de cycle accessible dans l'automate le repr\'esentant. Or on sait construire un automate ($(A\times \overline{\det(L)})[\varepsilon/o] \times (A\times L)[\varepsilon/o]$) de taille $|A|^2 \times |L|^2$ reconnaissant ce langage et la d\'etection de cycle accessible peut se faire en temps lin\'eaire. On dispose donc d'un algorithme en $|A|^2 \times |L|^2$ pour d\'ecider si un syst\`eme est diagnosticable par rapport \`a un mod\`ele de fautes.

Note : La longueur du mot le plus long dans ce langage est la dur\'ee maximale pendant laquelle on ne sait pas si le syst\`eme a fait une faute ou non.
\subsection{Un exemple de la d\'ecision de la diagnosticabilit\'e}

Soit $A$ l'automate \`a diagnostiquer (\`a gauche) et $L$ l'automate de mod\`ele de fautes permanentes  (\`a droite) repr\'esent\'e ci dessous:

\begin{figure}[H]
	\centering
    	\begin{tikzpicture}
        	\node[draw,circle] (0) at (0,0) {0};
            \node[draw,circle] (1) at (1.25,1) {1};
            \node[draw,circle] (2) at (2.25,1) {2};
            \node[draw,circle] (3) at (3.25,1) {3};
            \node[draw,circle] (4) at (1.25,-1) {4};
            \node[draw,circle] (5) at (2.25,-1) {5};
            \draw[->,>=latex] (0) -> (1) node[midway,above]{$f$};
            \draw[->,>=latex] (1) -> (2) node[midway,above]{$a$};
            \draw[->,>=latex] (2) -> (3) node[midway,above]{$b$};
            \draw [->,>=latex] (3) edge[in=100,out=80,loop] node[above] {$a,b$} (3);
            \draw[->,>=latex] (0) -> (4) node[midway,above]{$a$};
            \draw[->,>=latex] (4) -> (5) node[midway,above]{$b$};
            \draw [->,>=latex] (5) edge[in=100,out=80,loop] node[above] {$a,b$} (5);            
        \end{tikzpicture}
    	\begin{tikzpicture}
        	\node[draw,circle] (1) at (0,0) {0};
            \node[draw,circle,fill=gray](2) at (3,0){1};
            \draw[->,>=latex] (1)->(2) node[midway,above]{$f$};
            \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$a,b$} (1);
            \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$a,b,f$} (2);
        \end{tikzpicture}
\end{figure}

Etape 2 : Nous faisons le produit synchrone sur les deux automates(\`a gauche), puis la projection sur l'alphabet observable(\`a droite) a fin de faciliter les \'etapes suivants nous avons renomm\'e les \'etats dans l'automate projet\'e. 



\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\node[draw,circle] (0) at (0,0) {0,0};
        \node[draw,circle,fill=gray] (1) at (1.25,1) {1,1};
        \node[draw,circle,fill=gray] (2) at (2.75,1) {2,1};
        \node[draw,circle,fill=gray] (3) at (4.25,1) {3,1};
        \node[draw,circle] (4) at (1.25,-1) {4,0};
        \node[draw,circle] (5) at (2.75,-1) {5,0};
        \draw[->,>=latex] (0) -> (1) node[midway,above]{$f$};
        \draw[->,>=latex] (1) -> (2) node[midway,above]{$a$};
        \draw[->,>=latex] (2) -> (3) node[midway,above]{$b$};
        \draw [->,>=latex] (3) edge[in=100,out=80,loop] node[above] {$a,b$} (3);
        \draw[->,>=latex] (0) -> (4) node[midway,above]{$a$};
        \draw[->,>=latex] (4) -> (5) node[midway,above]{$b$};
        \draw [->,>=latex] (5) edge[in=100,out=80,loop] node[above] {$a,b$} (5);
	\end{tikzpicture}
	\begin{tikzpicture}
		\node[draw,circle] (0) at (0,0) {0};
        \node[draw,circle,fill=gray] (1) at (1.25,1) {1};
        \node[draw,circle,fill=gray] (2) at (2.75,1) {2};
        \node[draw,circle] (3) at (1.25,-1) {3};
        \node[draw,circle] (4) at (2.75,-1) {4};
        \draw[->,>=latex] (0) -> (1) node[midway,above]{$a$};
        \draw[->,>=latex] (1) -> (2) node[midway,above]{$b$};
        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$a,b$} (3);
        \draw[->,>=latex] (0) -> (3) node[midway,above]{$a$};
        \draw[->,>=latex] (3) -> (4) node[midway,above]{$b$};
        \draw [->,>=latex] (4) edge[in=100,out=80,loop] node[above] {$a,b$} (5);
	\end{tikzpicture}		
\end{figure}
		
Etape 3 : Nous construisons l'automate compl\'ementaire de l'automate de mod\`ele de fautes(\`a gauche), et nous faisons le produit avec l'automate \`a diagnostiquer pour construire l'automate qui reconna\^it $\mathcal L(A) \setminus \mathcal L(L)$ qui est le langage des ex\'ecutions sans faute (\`a droite).

\begin{figure}[H]
	\centering
    	\begin{tikzpicture}
        	\node[draw,circle,fill=gray] (1) at (0,0) {0};
            \node[draw,circle](2) at (3,0){1};
            \draw[->,>=latex] (1)->(2) node[midway,above]{$f$};
            \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$a,b$} (1);
            \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$a,b,f$} (2);
        \end{tikzpicture}
        \begin{tikzpicture}
        	\node[draw,circle,fill=gray] (0) at (0,0) {0,0};
        	\node[draw,circle] (1) at (1.25,1) {1,1};
        	\node[draw,circle] (2) at (2.75,1) {2,1};
        	\node[draw,circle] (3) at (4.25,1) {3,1};
        	\node[draw,circle,fill=gray] (4) at (1.25,-1) {4,0};
        	\node[draw,circle,fill=gray] (5) at (2.75,-1) {5,0};
        	\draw[->,>=latex] (0) -> (1) node[midway,above]{$f$};
        	\draw[->,>=latex] (1) -> (2) node[midway,above]{$a$};
        	\draw[->,>=latex] (2) -> (3) node[midway,above]{$b$};
        	\draw [->,>=latex] (3) edge[in=100,out=80,loop] node[above] {$a,b$} (3);
        	\draw[->,>=latex] (0) -> (4) node[midway,above]{$a$};
        	\draw[->,>=latex] (4) -> (5) node[midway,above]{$b$};
        	\draw [->,>=latex] (5) edge[in=100,out=80,loop] node[above] {$a,b$} (5);
        \end{tikzpicture}
\end{figure}

Etape 4 : Nous renomme les \'etats de l'automate qui reconna\^it $\mathcal L(A) \setminus \mathcal L(L)$(\`a gauche), et nous faisons le produit synchrone de cet automate avec le deuxi\`eme automate dans l'\'etape 2 qui reconna\^it le langage $\pi_{\Sigma_o}(\mathcal L (A) \cap \mathcal L(L))$.

\begin{figure}[H]
	\centering
        \begin{tikzpicture}
        	\node[draw,circle,fill=gray] (0) at (0,0) {0};
        	\node[draw,circle] (1) at (1.25,1) {1};
        	\node[draw,circle] (2) at (2.75,1) {2};
        	\node[draw,circle] (3) at (4.25,1) {3};
        	\node[draw,circle,fill=gray] (4) at (1.25,-1) {4};
        	\node[draw,circle,fill=gray] (5) at (2.75,-1) {5};
        	\draw[->,>=latex] (0) -> (1) node[midway,above]{$f$};
        	\draw[->,>=latex] (1) -> (2) node[midway,above]{$a$};
        	\draw[->,>=latex] (2) -> (3) node[midway,above]{$b$};
        	\draw [->,>=latex] (3) edge[in=100,out=80,loop] node[above] {$a,b$} (3);
        	\draw[->,>=latex] (0) -> (4) node[midway,above]{$a$};
        	\draw[->,>=latex] (4) -> (5) node[midway,above]{$b$};
        	\draw [->,>=latex] (5) edge[in=100,out=80,loop] node[above] {$a,b$} (5);
        \end{tikzpicture}
        \begin{tikzpicture}
			\node[draw,circle] (0) at (0,0) {0,0};
        	\node[draw,circle,fill=gray] (1) at (1.25,1) {4,1};
        	\node[draw,circle,fill=gray] (2) at (2.75,1) {5,2};
        	\node[draw,circle] (3) at (1.25,-1) {4,3};
        	\node[draw,circle] (4) at (2.75,-1) {5,4};
        	\draw[->,>=latex] (0) -> (1) node[midway,above]{$a$};
        	\draw[->,>=latex] (1) -> (2) node[midway,above]{$b$};
        	\draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$a,b$} (3);
        	\draw[->,>=latex] (0) -> (3) node[midway,above]{$a$};
        	\draw[->,>=latex] (3) -> (4) node[midway,above]{$b$};
        	\draw [->,>=latex] (4) edge[in=100,out=80,loop] node[above] {$a,b$} (5);
	\end{tikzpicture}
	
	Dans le dernier automate nous voyons qu'il y a un cycle infini qui est $(5,2) \xrightarrow{a,b} (5,2) \xrightarrow{a,b} \dots $.
	
	Donc l'automate \`a diagnostiquer n'est pas diagnosticable.
\end{figure}




\section{D\'efinitions de l'opacit\'e}

\subsection{Quelques d\'efinitions de base}

Nous allons d'abord donner quelques d\'efinitions sur le syst\`eme de transition d'\'etats \'etiquett\'e afin d'introduire les conceptions de opacit\'e.

\subsubsection{Syst\`eme de transition d'\'etats \'etiquett\'e (LTS)}

Un syst\`eme de transition d'\'etats \'etiquett\'e LTS est un quadruplet 

$$LTS = (S,L,\Delta,S_0)$$

avec
\begin{itemize}
	\item $S$ : un ensemble d'\'etats (potentiellement infini)
	\item $L$ : un ensemble de labels(potentiellement infini)
	\item $\Delta \subseteq S\times L \times S$ : une relation de transition
	\item $S_0$ : un ensemble fini non vide des \'etats initiaux 
\end{itemize}

Remarque : dans la suite nous consid\'erons que des syst\`eme de transition d'\'etats \'etiquett\'e d\'eterministe.

\subsubsection{Run}	

Un $Run$ d'un LTS est un couple $(s_0,\lambda)$ avec :

\begin{itemize}
	\item $s_0 \in S_0$
	\item $\lambda = l_1 \dots l_n$ : une s\'equence finie des \'etiquettes telle qu'il existe $s_1,s_2,\dots ,s_n \in S$ tels que $\forall i \in \{1, \dots n\}, (s_{i-1},l_i,s_i) \in \Delta$ 
\end{itemize}

Notons $s_n$ par $s_0\oplus \lambda$, remarquons que dans la sous-section pr\'ec\'edente nous avons fait l'hypoth\`ese que le $LTS$ est d\'eterministe, donc $s_0\oplus \lambda$ est bien d\'efini.

L'ensemble des tous les $Run$ est not\'e par $Run(LTS)$.

Nous notons le langage g\'en\'er\'e par $LTS$ par 

$$\mathcal{L}(LTS) = \{\lambda | \exists s_0 \in S_0 \mbox{ tel que } (s_0,\lambda) \in Run(LTS)\}$$


\subsection{Observabilit\'e et opacit\'e}

Jeremy Bryans, Maciej Koutny, Laurent Mazar{\'{e}}, Peter Y. A. Ryan a propos\'e dans leur article ~\cite{BryansKMR08}

Soit $LTS=(S,L,\Delta,S_0)$ est un syst\`eme de transition d'\'etats \'etiquett\'e, et $\Sigma_{obs}$ est un ensemble des \'el\'ements $observables$. Remarque nous notons que $\Sigma_{obs}^{\varepsilon} = \Sigma_{obs} \cup \{\varepsilon\}$

Nous allons maintenant mod\'eliser les diff\'erentes capacit\'es d'observation sur le syst\`eme qui est mod\'elis\'e par un LTS. Nous commen\c cons par d\'efinir les diff\'erents fonctions d'observations

\subsubsection{Diff\'erents fonctions d'observation et leur capacit\'e d'observation}

Nous d\'efinissons toutes les fonctions $\Omega : Run(LTS) \rightarrow \Sigma_{obs}^*$ comme les fonctions   
 d'observation.
 
Il y a plusieurs types de capacit\'e d'observation : 


$statique/dynamique/orwellian/m-orwellian(m\geq 1)$ :
		
Il existe une <<fonction d'observation>> sur les mots compos\'es par les \'etiquettes $\Omega_{etiq} : \Sigma^* \rightarrow \Sigma_{obs}^{\varepsilon}$ telle que 
	
	$$\forall (s,\lambda)= (s,l_1\dots l_n) \in Run(LTS), \Omega(s,\lambda) = \Omega_{etiq}(k_1)\circ\Omega_{etiq}(k_2)\circ\dots\circ\Omega_{etiq}(k_n)$$
	
	Ce sont les diff\'erents choix de $(k_1,\dots, k_n)$ qui d\'efinissent la capacit\'e d'observation.
	



\begin{itemize}
        \item Statique : $k_i = l_i$ 
	\item Dynamique : $k_i = l_1 \dots l_i$
	\item Orwellian : $k_i = \lambda$
	\item m-orwellian : $k_i = l_{max(1,i-m+1)} \dots l_{min(n,i+m-1)}$		

\end{itemize}

	Remarque : la notion $statique$ et $orwellian$ se r\'eduisent en cas particulier de $m-orwellian$, $statique$ est $1-orwellian$ et $orwellian$ est $\infty-orwellian$.

	
\subsubsection{Diff\'erents types d'Opacit\'e}

\begin{mydef}
	Soit $\Omega$ une fonction d'observation et $Secret$ un sous-ensemble de $Run(LTS)$. Nous disons que $Secret$ est opaque par rapport \`a $\Omega$ si et seulement si
	
	$$\forall (s,\lambda) \in Secret, \exists (s',\lambda')\not\in Secret \mbox{ tel que } \Omega(s,\lambda) = \Omega (s',\lambda')$$
	
	ou nous pouvons voir cette d\'efinition en terme d'ensembles :
	
	$$\Omega(Secret)\subseteq \Omega(Run(LTS)-Secret)$$
\end{mydef}

\subsubsection{Exemples des syst\`emes opaques}
		\begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (0) at (0,0) {0};
                        \node[draw,circle] (1) at (3,2) {1};
                        \node[draw,circle] (2) at (3,-2) {2};
                        \node[draw,circle] (3) at (6,1) {3};
                        \node[draw,circle] (4) at (6,3) {4};
                        \node[draw,circle] (5) at (6,-2) {5};
                        \draw[->,>=latex,line width = 1mm] (0)->(1) node[midway,above]{$h$};
                        \draw[->,>=latex] (0)->(2) node[midway,above]{$p$};
                        \draw[->,>=latex] (1)->(3) node[midway,above]{$a$};
                        \draw[->,>=latex] (1)->(4) node[midway,above]{$b$};
                        \draw[->,>=latex] (2)->(5) node[midway,above]{$a$};
                \end{tikzpicture}
                \caption{$\Sigma = \{h,p,a,b\}$,$\Sigma_o = {a,b}$, Le langage que nous cherchons \`a rendre opaque est $L = \Sigma^*.h.\Sigma^*$}
		\end{figure}		
		
Nous pouvons aussi d\'efinir les diff\'erents niveaux d'opacit\'e comme pour les fonction d'observation. Nous disons que $Secret$ est $init-opaque/final-opaque/total-opaque$ s'il existe un sous-ensemble  $Secret'$ de l'ensemble des \'etats de $LTS$ tel que :

$$\forall (s,\lambda) \in Run(LTS), (s,lambda) \in Secret \Leftrightarrow \sigma \in Secret'$$

C'est le choix de sigma qui va d\'efinir les diff\'erents niveaux d'opacit\'e :

\begin{itemize}
	\item $initial-opaque$ : $\sigma = s$
	\item $final-opaque$ : $\sigma = s\oplus \lambda$
	\item $total-opaque$ : $\sigma = s s_1 \dots s_n \mbox{ avec } s_i = s\oplus(l_1\dots l_n)$
\end{itemize} 

\section{Non-interf\'erence}

L'id\'ee de base de la non-interf\'erence est que les labels sont soit high, soit low. Les labels low sont visibles par tout le monde alors que les labels high sont priv\'es. Un LTS est dit non-interf\'erent si il n'est pas possible de d\'etecter la pr\'esence d'un label high dans un run en observant uniquement les labels low.~\cite{GorrieriV10}

\begin{mydef}
  Soit $LTS = (S,L,\Delta,S_0)$ un syst\`eme de transition d'\'etats \'etiquett\'e avec $L=L_{high}\sqcup L_{low}$. $LTS$ est non-interf\'erent ssi $\pi_{L_{low}}(L(LTS)) \subseteq L(LTS)$, c'est-\`a-dire si pour chaque run de $LTS$, le run o\`u l'on a enlev\'e tous les \'el\'ements de $L_{high}$ est encore un run.
\end{mydef}

Th : Toute propri\'et\'e d'opacit\'e initiale reposant sur une fonction d'observation statique peit se r\'eduire \`a un probl\`eme  de non-interf\'erence.

Th : Tout probl\`eme de non-interf\'erence peut se r\'eduire \`a un probl\`eme d'opacit\'e reposant sur une fonction 'dobservation statique.
\section{Conclusion}

Dans un premier temps, nous avons présenté le problème du diagnostique d'un langage rationnel sur un $LTS$. Pour le résoudre on a montré comment construire un diagnostiqueur à partir d'un tel modèle de faute et du $LTS$. Mais on ne peut pas toujours se fier au diagnostiqueur : il existe des LTS où des fautes ne peuvent être diagnostiquées. On a donc présenté ensuite un algorithme polynomial pour décider de la diagnosticabilité. Ensuite, nous avons présenté le problème de l'opacité  qui est le dual de la diagnosticabilité. Après avoir présenté plusieurs modèles d'observateurs plus ou moins puissants, on a montré que le problème de la diagnosticabilité peut se réduire à celui de l'opacité lorsque l'observateur est statique. L'opacité est donc un modèle très général pour modéliser les propriétés de sécurités de systèmes complexes.


\bibliography{bibliography}
\end{document}


