\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{float}
\newtheorem {mydef} {D\'efinition}
\newcommand{\enum}[2]{\llbracket #1, #2 \rrbracket}
\begin{document}

    \title{Diagnosability}

    \author{François Godi, Xavier Montillet, Chen Qian}

\section{Pr\'erequis}

\subsection{Automates}

Un automate fini indéterministe (avec $\varepsilon$-transitions) est un 5-uplet
$$A = (Q, \Sigma, \Delta, q_0, F)$$
o\`u
\begin{itemize}
	\item $Q$ est l'ensemble fini des états du système.
	\item $\Sigma$ est l'ensemble des événements.
	\item $\Delta \subseteq (Q \times (\Sigma \cup \{\varepsilon\}) \times Q)$ est une relation de transition.
	\item $q_0 \in Q$ l'état initial.
	\item $F$ l'ensemble des \'etats finaux.
\end{itemize}

\'Etant donn\'es $p,q \in Q$ et $l\in \Sigma \cup \{\varepsilon\}$, on notera $p \overset{l}{{\to}}q$ pour $(p,l,q) \in \Delta$.

On notera \'egalement $q_0 \overset{l_0}{{\to}} \dots \overset{l_n}{{\to}} q_{n+1}$ pour $\forall k \in \enum{0}{n}, q_k \overset{l_k}{{\to}} q_{k+1}$.



On dit qu'un automate fini ind\'eterministe est sans $\varepsilon$-transitions lorsque qu'il est tel que  $\Delta \subseteq (Q\times \Sigma \times Q)$.

Un automate fini d\'eterministe est un automate fini ind\'eterministe sans $\varepsilon$-transitions tel que $\Delta$ peut \^etre vue comme une fonction de $Q\times \Sigma$ dans $Q$: $\forall p,q,q' \in Q, \forall l \in \Sigma, p\overset{l}{{\to}}q \land p\overset{l}{{\to}}q' \implies q=q'$

\subsection{Langage reconnu}

Un mot $u_1...u_n \in \Sigma^*$ est reconnu par un automate $A$ si il existe $q_1,...,q_n \in Q$ tel que $q_0 \overset{u_1}{{\to}} q_1 \overset{u_2}{{\to}} \dots \overset{u_n}{{\to}} q_{n+1}$.

Le langage $L(A)$ reconnu par un automate $A$ est l'ensemble des mots de $\Sigma^*$ reconnus par $A$.

\subsection{Produit synchrone}

Soit $A = (Q, \Sigma, \Delta, q_0, F)$ et $A' = (Q', \Sigma', \Delta', q_0', F')$. On définit le produit synchrone de ces automates comme \'etant $$A\times A' = (Q \times Q', \Sigma \cap \Sigma', \Delta'', (q_0, q_0'), F\times F')$$ o\`u $\Delta''$ est d\'efinie par $(p,p')\overset{l}{{\to}}(q,q')$ si et seulement si $p\overset{l}{{\to}}q$ et $p'\overset{l}{{\to}}q'$.

On notera que $L(A\times B) = L(A) \cap L(B)$.

\subsection{$\varepsilon$-clôture}

On définit  $\operatorname{cl}_\varepsilon(A) = (Q, \Sigma, \Delta', q_0, F)$, l'$\varepsilon$-clôture \`a gauche de l'automate $A$.

$\Delta'$ est d\'efinie par $p \overset{l}{{\to}} r$ si et seulement si $\exists q_1,\dots,q_n \in Q,$ tels que dans l'automate $A$ on a  $p \overset{\varepsilon}{{\to}} q_1 \overset{\varepsilon}{{\to}} \dots \overset{\varepsilon}{{\to}} q_n \overset{l}{{\to}} r$.

On notera que $L(\operatorname{cl}_\varepsilon(A))=L(A)$.

\subsection{Projection}
%TODO automate correspondant

Soit $\Sigma'\subseteq \Sigma$. On d\'efinit la projection $P_{\Sigma \to \Sigma'}$ de $\Sigma^*$ dans $\Sigma'^*$ comme \'etant l'unique fonction v\'erifiant:

$$\forall a \in \Sigma \cup \{\varepsilon\}, \forall u \in \Sigma^*, P_{\Sigma \to \Sigma'}(au)=
\left\{\begin{array}{ll}
aP_{\Sigma \to \Sigma'}(u) &\text{si } a\in \Sigma'\\
P_{\Sigma \to \Sigma'}(u) &\text{sinon} \\
\end{array}\right.$$

\section{Diagnosticabilit\'e}

Un syst\`eme est diagnosticable si, lorsque une faute se produit, on peut la détecter en temps fini. On formalise cette notion de la fa\c{c}on suivante :
\begin{itemize}
	\item On se donne un alphabet $\Sigma=\Sigma_o\sqcup\Sigma_{no}$ o\`u $\Sigma_o$ est l'ensemble des \'ev\`enements observables et $\Sigma_{no}$ est l'ensemble des \'ev\`enements non observables.
	\item On repr\'esente le syst\`eme par un automate $\mathcal F$
	\item On repr\'esente le mod\`ele de faute par un langage r\'egulier $L$
\end{itemize}

On dit que le système $\mathcal F$ est diagnosticable si et seulement si $\exists n, \forall w \in \Sigma^*$ tel que $|P_{\Sigma \to \Sigma_o}(w)| \geq n, \forall u \in \Sigma^* L w$, on peut savoir qu'il existe un sous mot de $L$ dans $u$ à partir de $P_{\Sigma \to \Sigma_o}(u)$. 


\section{R\'eductions}

\subsection{I-diagnosticabilit\'e}

Soit $I \subset \Sigma$, On dit que le système $\mathcal F$ est I-diagnosticable si et seulement si $\exists n, \forall w \in \Sigma^*$ tel que $|P_{\Sigma \to \Sigma_o}(w)| \geq n, \forall u \in \Sigma^* L \Sigma^* I w$, on peut savoir qu'il existe un sous mot de $L$ dans $u$ à partir de $P_{\Sigma \to \Sigma_o}(u)$. 

Cela revient à étudier la diagnosticabilité avec le langage de fautes $L'=L \Sigma^* I$.

%\subsection{Vivant}

%TODO

\section{Algorithme de construction du diagnostiqueur}
    Nous allons présenter un algorithme pour construire un diagnostiqueur en temps exponentiel.
        \subsection{Automate de mod\`ele de faute}
   \begin{mydef}{Automate de mod\`ele de faute : }
 Un automate qui reconnait le langage de faute L. Les états finaux de l'automate sont appelés <<\'etats fautifs>>, les autres <<\'etats normaux>>.
 \end{mydef}
    
    \paragraph{Exemple (automate de mod\`ele de faute): } %Il faudrait ajouter les états initiaux (mais je ne sais pas comment faire)
    
   Soit $f\in \Sigma$, $L  = \{f\}$, les  nœuds blancs sont les états normaux et les nœuds gris sont les \'etats fautifs. 
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1)->(2) node[midway,above]{$f$};
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$\Sigma^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de faute simple}
        \end{figure}
Dans cet exemple, on veut modéliser des réparations, soit $f, r \in \Sigma$, $L  = \{f (\Sigma\backslash \{ r \})^* \}$        
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1) to[bend right=30] node[pos=0.5,below]{$f$}(2);
                        \draw[->,>=latex] (2) to[bend right=30] node[pos=0.5,above]{$r$}(1);
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$(\Sigma\backslash \{ r \})^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de fautes avec r\'eparations} 
    \end{figure}
            
    
    \subsection{Construction du diagnostiqueur}
    Pour construire un diagnostiqueur de l'automate $A$ avec l'automate de mod\`ele de faute $MF$, on proc\'ede de la mani\`ere suivante :
    
    \begin{enumerate}
            \item Faire le produit de l'automate $A$ avec l'automate $MF$. Un \'etat de $A\times MF$ est appel\'e un \'etat fautif si et seulement si c'est un produit d'un \'etat fautif de $MF$ avec un autre \'etat de $A$
            \item Remplacer les \'ev\`enements de $\Sigma_{no}$ par des $\varepsilon$-transitions et faire l'$\epsilon$-cl\^oture, $C = \varepsilon$-clôture$((A\times MF)[\varepsilon/f])$.
          \item D\'eterminiser l'automate $C$ avec l'algorithme des parties, on note $D$ l'automate d\'eterminis\'e. Un état de $D$ appartient à un ensemble isomorphe à $\mathcal{P}(Q)$, on dit que l'état de $D$ correspond à l'ensemble d'états de Q.
            \item Nous discriminons les diff\'erents \'etats de $D$ :
                    \begin{itemize}
                            \item  \'Etats normaux: Tous les \'etats correspondants à un ensemble d'\'etats non-fautifs.
                           \item \'Etats fautifs:  Tous les \'etats correspondants à un ensemble d'\'etats fautifs.
                            \item \'Etats de doute: Tous les \'etats correspondants à un ensemble composé à la fois d'\'etats fautifs et non-fautifs.
                    \end{itemize}  
                 
    \end{enumerate} 
     

\section{D\'ecision de la diagnosticabilit\'e en temps polynomial}

L'id\'ee de l'agorithme est qu'un automate est diagnosticable par rapport a un mod\`ele de fautes si et seulement si il existe des mots qui peuvent être observés qu'une faute se soit produite ou non. Le langage $\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F)$ est le langage des observations avec fautes. Le langage $\pi_{\Sigma_o}(\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F))$ est le langage est observations des ex\'ecutions avec faute. Le langage $\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F)$ est le langage des ex\'ecutions sans faute. Le langage $\pi_{\Sigma_o}(\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F))$ est le langage des observations d'ex\'ecutions sans faute. Donc $\pi_{\Sigma_o}(\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F)) \cap \pi_{\Sigma_o}(\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F))$ est le langage des observations ambiguës. Il suffit donc de v\'erifier que ce langage ne contient que des mots de taille born\'ee, ce qui est équivalent au fait qu'il soit fini, ce qui est \'equivalent \`a l'absence de cycle accessible dans l'automate le repr\'esentant. Or on sait construire un automate de taille $|\mathcal F|^2 \times |\mathcal A|^2$ reconnaissant ce langage et la d\'etection de cycle accessible peut se faire en temps lin\'eaire. On dispose donc d'un algorithme en $|\mathcal F|^2 \times |\mathcal A|^2$ pour d\'ecider si un automate est diagnosticable par rapport \`a un mod\`ele de fautes.

Note : La longueur du mot le plus long dans ce langage est la dur\'ee maximale pendant laquelle on ne sait pas si le syst\`eme a fait une faute ou non.

\end{document}
