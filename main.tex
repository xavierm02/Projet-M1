\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{float}
\newtheorem {mydef} {D\'efinition}
\newcommand{\enum}[2]{\llbracket #1, #2 \rrbracket}
\begin{document}

    \title{Diagnosability}

    \author{François Godi, Xavier Montillet, Chen Qian}

\section{Pr\'erequis}

\subsection{Automates}

Un automate fini indéterministe (avec $\varepsilon$-transitions) est un 5-uplet
$$A = (Q, \Sigma, \Delta, q_0, F)$$
o\`u
\begin{itemize}
	\item $Q$ est l'ensemble fini des états du système.
	\item $\Sigma$ est l'ensemble des événements.
	\item $\Delta \subseteq (Q \times (\Sigma \cup \{\varepsilon\}) \times Q)$ est une relation de transition.
	\item $q_0 \in Q$ l'état initial.
	\item $F$ l'ensemble des \'etats finaux.
\end{itemize}

\'Etant donn\'es $p,q \in Q$ et $l\in \Sigma \cup \{\varepsilon\}$, on notera $p \overset{l}{{\to}}q$ pour $(p,l,q) \in \Delta$.

On notera \'egalement $q_0 \overset{l_0}{{\to}} \dots \overset{l_n}{{\to}} q_{n+1}$ pour $\forall k \in \enum{0}{n}, q_k \overset{l_k}{{\to}} q_{k+1}$.



On dit qu'un automate fini ind\'eterministe est sans $\varepsilon$-transitions lorsque qu'il est tel que  $\Delta \subseteq (Q\times \Sigma \times Q)$.

Un automate fini d\'eterministe est un automate fini ind\'eterministe sans $\varepsilon$-transitions tel que $\Delta$ peut \^etre vue comme une fonction de $Q\times \Sigma$ dans $Q$: $\forall p,q,q' \in Q, \forall l \in \Sigma, p\overset{l}{{\to}}q \land p\overset{l}{{\to}}q' \implies q=q'$

\subsection{Langage reconnu}

Un mot $u_1...u_n \in \Sigma^*$ est reconnu par un automate $A$ si il existe $q_1,...,q_n \in Q$ tel que $q_0 \overset{u_1}{{\to}} q_1 \overset{u_2}{{\to}} \dots \overset{u_n}{{\to}} q_{n+1}$.

Le langage $L(A)$ reconnu par un automate $A$ est l'ensemble des mots de $\Sigma^*$ reconnus par $A$.

\subsection{Produit synchrone}

Soit $A = (Q, \Sigma, \Delta, q_0, F)$ et $A' = (Q', \Sigma, \Delta', q_0', F')$. On définit le produit synchrone de ces automates comme \'etant $$A\times A' = (Q \times Q', \Sigma, \Delta'', (q_0, q_0'), F\times F')$$ o\`u $\Delta''$ est d\'efinie par $(p,p')\overset{l}{{\to}}(q,q')$ si et seulement si $p\overset{l}{{\to}}q$ et $p'\overset{l}{{\to}}q'$.

On notera que $L(A\times B) = L(A) \cap L(B)$.

\subsection{$\varepsilon$-clôture}

On définit  $\operatorname{cl}_\varepsilon(A) = (Q, \Sigma, \Delta', q_0, F)$, l'$\varepsilon$-clôture \`a gauche de l'automate $A$.

$\Delta'$ est d\'efinie par $p \overset{l}{{\to}} r$ si et seulement si $\exists q_1,\dots,q_n \in Q,$ tels que dans l'automate $A$ on a  $p \overset{\varepsilon}{{\to}} q_1 \overset{\varepsilon}{{\to}} \dots \overset{\varepsilon}{{\to}} q_n \overset{l}{{\to}} r$.

On notera que $L(\operatorname{cl}_\varepsilon(A))=L(A)$.

\subsection{Projection}
%TODO automate correspondant

Soit $\Sigma'\subseteq \Sigma$. On d\'efinit la projection $P_{\Sigma \to \Sigma'}$ de $\Sigma^*$ dans $\Sigma'^*$ comme \'etant l'unique fonction v\'erifiant:

$$\forall a \in \Sigma \cup \{\varepsilon\}, \forall u \in \Sigma^*, P_{\Sigma \to \Sigma'}(au)=
\left\{\begin{array}{ll}
aP_{\Sigma \to \Sigma'}(u) &\text{si } a\in \Sigma'\\
P_{\Sigma \to \Sigma'}(u) &\text{sinon} \\
\end{array}\right.$$

\section{Diagnosticabilit\'e}

Diagnostiquer un syst\`eme, c'est d\'etecter s'il a fait une faute en un temps born\'e apr\`es la faute. On formalise cette notion de la fa\c{c}on suivante :
\begin{itemize}
	\item On se donne un alphabet $\Sigma=\Sigma_o\sqcup\Sigma_f$ o\`u $\Sigma_o$ est l'ensemble des \'ev\`enements observables et $\Sigma_f$ et l'ensemble des \'ev\`enements fautifs
	\item On repr\'esente le syst\`eme par un automate $\mathcal F$
	\item On repr\'esente le mod\`ele de faute par un langage r\'egulier $L$
	\item 
\end{itemize}

Lorsque un mot est généré par l'automate, à chaque transition, on peut observer l’événement de la transition si et seulement si cet événement est observable. Étant donné que :
\begin{enumerate}
\item Un événement fautif observable est trivialement diagnosticable.
\item Les transitions du système dont l'événement est non fautif et non observable peuvent déjà être modélisées par des $\varepsilon$-transitions.
\end{enumerate} 
On peut considérer sans perte de généralité que les observables sont les événements non fautifs, on note $\Sigma_0 = \Sigma \setminus \{f\}$ cet ensemble d'observables.
\paragraph{}
Soit $u \in \Sigma^*$, on note $l(u)$ sa longueur. On dit que $G$ est diagnosticable si pour tout mot $u$ généré par $G$, il existe $n \in \mathbb{N}$ tel que il suffit de connaître les $l(P(u)) + n$ premières lettres de $P(u)$ pour savoir si f est l'une des lettres de $u$. Soit $I \subset \Sigma$, on dit que $G$ est I-diagnosticable si pour tout mot $u$ généré par $G$ et se terminant par $\sigma \in I$, il existe $n \in \mathbb{N}$ tel que il suffit de connaître les $l(P(u)) + n$ premières lettres de $P(u)$ pour savoir si f est l'une des lettres de $u$.
Le système que l'on cherche à diagnostiqueur est modélisé par un automate fini ind\'eterministe avec $\varepsilon$-transitions tel que $F=Q$ et $f\in \Sigma$.


\section{R\'eductions}

\subsection{I-diagnosticabilit\'e}

TODO

\subsection{Vivant}

TODO

\section{Algorithme de construction du diagnostiqueur}
    Nous allons présenter un algorithme pour construire un diagnostiqueur en temps exponentiel.
        \subsection{Quelques notions}
   \begin{mydef}{Automate de mod\`ele de faute : }
                Un automate adapté au modèle de faute que l'on cherche à diagnostiquer. Plus formellement, nous posons un automate $MF = (\Sigma = \Sigma_n \bigsqcup \Sigma_f \bigsqcup \Sigma_r, Q = Q_n \bigsqcup Q_f,q_0,\Delta, F)$,  $Q_n$ est l'ensemble des <<\'etats normaux>> et $Q_f$ l'ensemble des <<\'etats fautifs>>, $\Sigma_n$  l'ensemble des <<\'ev\`enements normaux>>, $\Sigma_f$ l'ensemble des  <<\'ev\`enements fautifs>> et $\Sigma_r$ l'ensemble des <<\'ev\`enements r\'eparatifs>>. $MF$ respecte les propri\'et\'es suivantes, si nous avons une transition a$\xrightarrow{x}$b:
                \begin{center}
                \begin{tabular}{|c|c|c|}
                        \hline
                        & $a\in Q_n$ & $a\in Q_f$\\
                        \hline                        
                        $x\in \Sigma_n$ & $b\in \Sigma_n$&$b\in \Sigma_f$\\
                        \hline                        
                        $x\in \Sigma_f$ &$b\in \Sigma_f$&$b\in \Sigma_f$\\
                        \hline
                        $x\in \Sigma_r$ & $b\in \Sigma_n$ & $b \in \Sigma_n$\\
                        \hline
                \end{tabular}
                \end{center}
    \end{mydef}
    
    \paragraph{Exemple (automate des mod\`ele de fautes): } %Il faudrait ajouter les états initiaux (mais je ne sais pas comment faire)
    
    Dans les automates suivants, $ \Sigma_f  = \{f\}$, $ \Sigma_r  = \{r\}$, les  nœuds blancs sont les états normaux et les nœuds gris sont les \'etats fautifs. 
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1)->(2) node[midway,above]{$f$};
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$\Sigma^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de fautes permanentas}
        \end{figure}
        
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1) to[bend right=30] node[pos=0.5,below]{$f$}(2);
                        \draw[->,>=latex] (2) to[bend right=30] node[pos=0.5,above]{$r$}(1);
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$(\Sigma\backslash \{ r \})^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de fautes avec r\'eparations} 
    \end{figure}
            
    
    \subsection{Construction du diagnostiqueur}
    Pour construire les diagnostiqueurs de l'automate $A$ avec l'automate de mod\`ele de faute $MF$. Nous allons proc\'eder de la mani\`ere suivante :
    
    \begin{enumerate}
            \item Faire le  produit de l'automate $A$ avec l'automate $MF$. Un \'etat de $A\times MF$ est appel\'e un \'etat fautif si et seulement si c'est un produit d'un \'etat fautif de $MF$ avec un autre \'etat de $A$
            \item Remplacer les \'ev\`enements fautifs par des $\varepsilon$-transitions et faire l'$\epsilon$-cl\^oture, $C = \varepsilon$-clôture$((A\times MF)[\varepsilon/f])$.
          \item D\'eterminiser l'automate $C$, on note $D$ l'automate d\'eterminis\'e.
            \item Nous discriminons les diff\'erents \'etats de $D$ :
                    \begin{itemize}
                            \item  \'Etats normaux: Tous les \'etats correspondants à un ensemble d'\'etats non-fautifs.
                           \item \'Etats fautifs:  Tous les \'etats correspondants à un ensemble d'\'etats fautifs.
                            \item \'Etats de doute: Tous les \'etats correspondants à un ensemble composé à la fois d'\'etats fautifs et non-fautifs.
                    \end{itemize}  
                      L'intuition de cette appellation est la suivante : 
                    \begin{itemize}
                    \item Si nous arrivons dans un \'etat normal nous sommes s\^ur qu'aucun \'ev\`enenement fautif ne s'est produit dans notre syst\`eme. 
    \item Si nous arrivons dans un \'etat fautif nous sommes s\^ur qu'un \'ev\`enenement fautif s'est produit dans notre syst\`eme. 
            \item Si nous arrivons dans un \'etat de doute, nous ne pouvons pas d\'eterminer si \'ev\`enement fautif s'est produit.
\end{itemize}
    \end{enumerate} 
    \subsection{D\'eterminer les \'ev\`enements fautifs}
        Une fois que nous avons construit le diagnostiqueur $D$ de l'automate $A$ avec le mod\`ele de faute $MF$, l'article de Meera Sampath et Kasim Sinnamohideen propose de regarder les deux ensembles suivants :
        \begin{itemize}
             \item Ensemble $\mathcal{N} = $ tous les mots accept\'es par les \'etats normaux.  % "ou un cycle.." peu clair
             \item Ensemble $\mathcal{F} = $ tous les mots accept\'es par les \'etats fautifs. %idem
        \end{itemize}
    Nous pouvons dire que le syst\`eme est non-diagnosticable si et seulement si $\mathcal{N}\cap \mathcal{F}$ ne contient pas  mots infinis.% Pas de projection ?? 

\section{D\'ecision de la diagnosticabilit\'e en temps polynomial}

Soit $\mathcal A$ un automate fini ind\'eterministe avec $\varepsilon$-transitions et $\mathcal F$ un . un langage r\'egulier suffixe-clos TODO.

L'id\'ee de l'agorithme est qu'un automate est diagnosticable par rapport a un mod\`ele de fautes si et seulement si il existe des mots observable a la fois quand une faute a eu lieu et quand aucune faut n'a eu lieu de taille arbitraire. Le langage $\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F)$ est le langage des observations avec fautes. Le langage $\pi_{\Sigma_o}(\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F))$ est le langage est observations des ex\'ecutions avec faute. Le langage $\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F)$ est le langage des ex\'ecutions sans faute. Le langage $\pi_{\Sigma_o}(\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F))$ est le langage des observations d'ex\'ecutions sans faute. Donc $\pi_{\Sigma_o}(\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F)) \cap \pi_{\Sigma_o}(\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F))$ est le langage des observations ambigues. Il suffit donc de v\'erifier que ce langage ne contient que des mots de taille born\'ee, ce qui est equivalent au fait qu'il soit fini, ce qui est \'equivalent \`a l'abscence de cycle accessible dans l'automate le repr\'esentant. Or on sait construire un automate de taille $|\mathcal F|^2 \times |\mathcal A|^2$ reconnaissant ce langage et la d\'etection de cycle accessible peut se faire en temps lin\'eaire. On dispose donc d'un algorithme en $|\mathcal F|^2 \times |\mathcal A|^2$ pour d\'ecider si un automate est diagnosticable par rapport \`a un mod\`ele de fautes.

Note : La longueur du mot le plus long dans ce langage est la dur\'ee maximale pendant laquelle on ne sait pas si le syst\`eme a fait une faute ou non.


\section{D\'efinitions de l'opacit\'e}

\subsection{Quelques d\'efinitions de base}

Nous allons d'abord donner quelques d\'efinition sur le syst\`eme de transition d'\'etats \'etiquett\'e afin d'introduire les conceptions de opacit\'e.

\subsubsection{Syst\`eme de transition d'\'etats \'etiquett\'e (LTS)}

Un syst\`eme de transition d'\'etats \'etiquett\'e LTS est un quadruplet 

$$LTS = (S,L,\Delta,S_0)$$

avec
\begin{itemize}
	\item $S$ : un ensemble d'\'etats (potentiellement infini)
	\item $L$ : un ensemble de labels(potentiellement infini)
	\item $\Delta \subseteq S\times L \times S$ : une relation de transition
	\item $S_0$ : un ensemble fini non vide des \'etats initiaux 
\end{itemize}

Remarque : dans la suite nous consid\'erons que des syst\`eme de transition d'\'etats \'etiquett\'e d\'eterministe.

\subsubsection{Run}

Un $Run$ d'un LTS est un couple $(s_0,\lambda)$ avec :

\begin{itemize}
	\item $s_0 \in S_0$
	\item $\lambda = l_1 \dots l_n$ : une s\'equence finie des \'etiquettes telle qu'il existe $s_1,s_2,\dots ,s_n \in S$ tels que $\forall i \in \{1, \dots n\}, (s_{i-1},l_i,s_i) \in \Delta$ 
\end{itemize}

Notons $s_n$ par $s\oplus \lambda$, remarquons que dans la sous-section pr\'ec\'edente nous avons fait l'hypoth\`ese que le $LTS$ est d\'eterministe, donc $s\oplus \lambda$ est bien d\'efini.

L'ensemble des tous les $Run$ est not\'e par $Run(LTS)$.

Nous notons le langage g\'en\'er\'e par $LTS$ par 

$$\mathcal{L}(LTS) = \{\lambda | \exists s_0 \in S_0 \mbox{ tel que } (s_0,\lambda) \in Run(LTS)\}$$


\subsection{Observabilit\'e et l'opacit\'e}

Soit $LTS=(S,L,\Delta,S_0)$ est un syst\`eme de transition d'\'etats \'etiquett\'e, et $\Sigma_{obs}$ est un ensemble des \'el\'ements $observables$. Remarque nous notons que $\Sigma_{obs}^{\varepsilon} = \Sigma_{obs} \cup \{\varepsilon\}$

Nous allons maintenant mod\'eliser les diff\'erentes capacit\'es d'observation sur le syst\`eme qui est mod\'elis\'e par un LTS. Nous commen\c cons par d\'efinir les diff\'erents fonctions d'observations

\subsubsection{Diff\'erents fonctions d'observation et leur capacit\'e d'observation}

Nous d\'efinissons toutes les fonctions $\Omega : Run(LTS) \rightarrow \Sigma_{obs}^*$ comme les fonctions   
 d'observation.
 
Il y a plusieurs types de capacit\'e d'observation : 



\begin{itemize}
	\item statique : il existe une <<fonction d'observation>> sur les \'etiquette $\Omega_{etiq} : L \rightarrow \Sigma_{obs}^{\varepsilon}$ telle que 
	
	$$\forall (s,\lambda)= (s,l_1\dots l_n) \in Run(LTS), \Omega(s,\lambda) = \Omega_{etiq}(l_1)\circ\Omega_{etiq}(l_2)\circ\dots\circ\Omega_{etiq}(l_n)$$
	\item $dynamique/orwellian/m-orwellian(m\geq 1)$ :
		
		Il existe une <<fonction d'observation>> sur les \'etiquette $\Omega_{etiq} : L\times L^* \rightarrow \Sigma_{obs}^{\varepsilon}$ telle que 
	
	$$\forall (s,\lambda)= (s,l_1\dots l_n) \in Run(LTS), \Omega(s,\lambda) = \Omega_{etiq}(k_1)\circ\Omega_{etiq}(k_2)\circ\dots\circ\Omega_{etiq}(k_n)$$
	
	Ce sont les diff\'erents choix de $(k_1,\dots, k_n)$ qui d\'efinissent la capacit\'e d'observation.
	
	\begin{itemize}
		\item Dynamique : $k_i = l_1 \dots l_i$
		\item Orwellian : $k_i = \lambda$
		\item m-orwellian : $k_i = l_{max(1,i-m+1)} \dots l_{min(n,i+m-1)}$		
	\end{itemize}
\end{itemize}

	Remarque : la notion $statique$ et $orwellian$ se r\'eduisent en cas particulier de $m-orwellian$, $statique$ est $1-orwellian$ et $orwellian$ est $\infty-orwellian$.

\subsubsection{Pr\'edicat $Prop$}	
	Nous d\'efinissons un pr\'edicat $Prop$ sur $Run(LTS)$. Notons $\Sigma_{Prop}$ ensemble des \'el\'ements de $Run(LTS)$ tel que $Prop$ est vrais.
	
\subsubsection{Diff\'erents types d'Opacit\'e}

\begin{mydef}
	Soit $\Omega$ une fonction d'observation et $Prop$ un pr\'edicat sur $Run(LTS)$. Nous disons que $Prop$ est opaque par rapport \`a $\Omega$ si et seulement si
	
	$$\forall (s,\lambda) \in \Sigma_{Prop}, \exists (s',\lambda')\not\in \Sigma_{Prop} \mbox{ tel que } \Omega(s,\lambda) = \Omega (s',\lambda')$$
	
	ou nous pouvons voir cette d\'efinition en terme d'ensembles :
	
	$$\Omega(Run(LTS)\cap \Sigma_{Prop})\subseteq \Omega(Run(LTS)-\Sigma_{Prop})$$
\end{mydef}

Nous pouvons aussi d\'efinir les diff\'erents niveaux d'opacit\'e comme pour les fonction d'observation. Nous disons que $Prop$ et $init-opaque/final-opaque/total-opaque$ s'il existe un pr\'edicat $Prop_2$ sur $S$ l'ensemble des \'etats de $LTS$ tel que :

$$\forall (s,\lambda) \in Run(LTS), Prop(s,lambda) = Prop_2(\sigma)$$

C'est le choix de sigma qui va d\'efinir les diff\'erents niveaux d'opacit\'e :

\begin{itemize}
	\item $initial-opaque$ : $\sigma = s$
	\item $final-opaque$ : $\sigma = s\oplus \lambda$
	\item $total-opaque$ : $\sigma = s s_1 \dots s_n \mbox{ avec } s_i = s\oplus(l_1\dots l_n)$
\end{itemize} 

\section{Non-interf\'erence}

L'id\'ee de base de la non-interf\'erence est que les labels sont soit high, soit low. Les labels low sont visibles par tout le monde alors que les labels high sont priv\'es. Un LTS est dit non-interf\'erent si il n'est pas possible de d\'etecter la pr\'esence d'un label high dans un run en observant uniquement les labels low.

\begin{mydef}
  Soit $LTS = (S,L,\Delta,S_0)$ un syst\`eme de transition d'\'etats \'etiquett\'e avec $L=L_{high}\sqcup L_{low}$. $LTS$ est non-interf\'erent ssi $P_{L\to L_{low}}(L(LTS)) \subseteq L(LTS)$, c'est-\`a-dire si pour chaque run de $LTS$, le run o\`u l'on a enlev\'e tous les \'el\'ements de $L_{high}$ est encore un run.
\end{mydef}

Th : Toute propri\'et\'e d'opacit\'e initiale reposant sur une fonction d'observation statique peit se r\'eduire \`a un probl\`eme  de non-interf\'erence.

Th : Tout probl\`eme de non-interf\'erence peut se r\'eduire \`a un probl\`eme d'opacit\'e reposant sur une fonction 'dobservation statique.
\end{document}
