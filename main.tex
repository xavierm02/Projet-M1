\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{float}
\newtheorem {mydef} {D\'efinition}
\newcommand{\enum}[2]{\llbracket #1, #2 \rrbracket}
\begin{document}

    \title{Diagnosability}

    \author{François Godi, Xavier Montillet, Chen Qian}

\section{Pr\'erequis}

\subsection{Automates}

Un automate fini indéterministe (avec $\varepsilon$-transitions) est un 5-uplet
$$A = (Q, \Sigma, \Delta, q_0, F)$$
o\`u
\begin{itemize}
	\item $Q$ est l'ensemble fini des états du système.
	\item $\Sigma$ est l'ensemble des événements.
	\item $\Delta \subseteq (Q \times (\Sigma \cup \{\varepsilon\}) \times Q)$ est une relation de transition.
	\item $q_0 \in Q$ l'état initial.
	\item $F$ l'ensemble des \'etats finaux.
\end{itemize}

\'Etant donn\'es $p,q \in Q$ et $l\in \Sigma \cup \{\varepsilon\}$, on notera $p \overset{l}{{\to}}q$ pour $(p,l,q) \in \Delta$.

On notera \'egalement $q_0 \overset{l_0}{{\to}} \dots \overset{l_n}{{\to}} q_{n+1}$ pour $\forall k \in \enum{0}{n}, q_k \overset{l_k}{{\to}} q_{k+1}$.



On dit qu'un automate fini ind\'eterministe est sans $\varepsilon$-transitions lorsque qu'il est tel que  $\Delta \subseteq (Q\times \Sigma \times Q)$.

Un automate fini d\'eterministe est un automate fini ind\'eterministe sans $\varepsilon$-transitions tel que $\Delta$ peut \^etre vue comme une fonction de $Q\times \Sigma$ dans $Q$: $\forall p,q,q' \in Q, \forall l \in \Sigma, p\overset{l}{{\to}}q \land p\overset{l}{{\to}}q' \implies q=q'$

\subsection{Langage reconnu}

Un mot $u_1...u_n \in \Sigma^*$ est reconnu par un automate $A$ si il existe $q_1,...,q_n \in Q$ tel que $q_0 \overset{u_1}{{\to}} q_1 \overset{u_2}{{\to}} \dots \overset{u_n}{{\to}} q_{n+1}$ et $q_{n+1} \in F$.

Le langage $L(A)$ reconnu par un automate $A$ est l'ensemble des mots de $\Sigma^*$ reconnus par $A$.

\subsection{Produit synchrone}

Soit $A = (Q, \Sigma, \Delta, q_0, F)$ et $A' = (Q', \Sigma', \Delta', q_0', F')$. On définit le produit synchrone de ces automates comme \'etant $$A\times A' = (Q \times Q', \Sigma \cap \Sigma', \Delta'', (q_0, q_0'), F\times F')$$ o\`u $\Delta''$ est d\'efinie par $(p,p')\overset{l}{{\to}}(q,q')$ si et seulement si $p\overset{l}{{\to}}q$ et $p'\overset{l}{{\to}}q'$.

On notera que $L(A\times B) = L(A) \cap L(B)$.

\subsection{$\varepsilon$-clôture}

On définit  $\operatorname{cl}_\varepsilon(A) = (Q, \Sigma, \Delta', q_0, F)$, l'$\varepsilon$-clôture \`a gauche de l'automate $A$.

$\Delta'$ est d\'efinie par $p \overset{l}{{\to}} r$ si et seulement si $\exists q_1,\dots,q_n \in Q,$ tels que dans l'automate $A$ on a  $p \overset{\varepsilon}{{\to}} q_1 \overset{\varepsilon}{{\to}} \dots \overset{\varepsilon}{{\to}} q_n \overset{l}{{\to}} r$.

On notera que $L(\operatorname{cl}_\varepsilon(A))=L(A)$.

\subsection{Projection}
%TODO automate correspondant

Soit $\Sigma'\subseteq \Sigma$. On d\'efinit la projection $\pi_{\Sigma'}$ de $\Sigma^*$ dans $\Sigma'^*$ comme \'etant l'unique fonction v\'erifiant:

$$\forall a \in \Sigma \cup \{\varepsilon\}, \forall u \in \Sigma^*, \pi_{\Sigma'}(au)=
\left\{\begin{array}{ll}
a\pi_{\Sigma'}(u) &\text{si } a\in \Sigma'\\
\pi_{\Sigma'}(u) &\text{sinon} \\
\end{array}\right.$$

\section{Diagnosticabilit\'e}

Un syst\`eme extension-clos est diagnosticable si, lorsque une faute se produit, on peut la détecter en temps fini. On formalise cette notion de la fa\c{c}on suivante :
\begin{itemize}
	\item On se donne un alphabet $\Sigma=\Sigma_o\sqcup\Sigma_{no}$ o\`u $\Sigma_o$ est l'ensemble des \'ev\`enements observables et $\Sigma_{no}$ est l'ensemble des \'ev\`enements non observables.
	\item On repr\'esente le syst\`eme par un automate $\mathcal F$
	\item On repr\'esente le mod\`ele de faute par un langage r\'egulier $L$
\end{itemize}

On dit que le système $\mathcal F$ est diagnosticable si et seulement si $\exists n, \forall  f \in L, \forall w \in \Sigma^*$ tel que $||\pi_{\Sigma_o}(w)| \geq n, \forall u \in \Sigma^* f w$, on peut savoir que f est un sous mot de $u$ en observant $|\pi_{\Sigma_o}(u)$. 


\section{R\'eductions}

\subsection{I-diagnosticabilit\'e}


Soit $I \subset \Sigma$, On dit que le système $\mathcal F$ est I-diagnosticable si et seulement si $\exists n, \forall  f \in L, \forall w \in \Sigma^*$ tel que $|\pi_{\Sigma_o}(w)| \geq n, \forall u \in \Sigma^*f \Sigma^* I w$, on peut savoir que f est un sous mot de $u$ en observant $|\pi_{\Sigma_o}(u)$. 


Cela revient à étudier la diagnosticabilité avec le langage de fautes $L'=L \Sigma^* I$.

%\subsection{Vivant}

%TODO

\section{Algorithme de construction du diagnostiqueur}
    Nous allons présenter un algorithme pour construire un diagnostiqueur en temps exponentiel.
        \subsection{Automate de mod\`ele de faute}
   \begin{mydef}{Automate de mod\`ele de faute : }
 Un automate qui reconnait le langage de faute L. Les états finaux de l'automate sont appelés <<\'etats fautifs>>, les autres <<\'etats normaux>>.
 \end{mydef}
    
    \paragraph{Exemple (automate de mod\`ele de faute): } %Il faudrait ajouter les états initiaux (mais je ne sais pas comment faire)
    
   Soit $f\in \Sigma$, $L  = \{f\}$, les  nœuds blancs sont les états normaux et les nœuds gris sont les \'etats fautifs. 
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1)->(2) node[midway,above]{$f$};
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$\Sigma^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de faute simple}
        \end{figure}
Dans cet exemple, on veut modéliser des réparations, soit $f, r \in \Sigma$, $L  = \{f (\Sigma\backslash \{ r \})^* \}$        
        \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                        \node[draw,circle] (1) at (0,0) {1};
                        \node[draw,circle,fill=gray](2) at (3,0){2};
                        \draw[->,>=latex] (1) to[bend right=30] node[pos=0.5,below]{$f$}(2);
                        \draw[->,>=latex] (2) to[bend right=30] node[pos=0.5,above]{$r$}(1);
                        \draw [->,>=latex] (1) edge[in=100,out=80,loop] node[above] {$(\Sigma \backslash \{ f \})^*$} (1);
                        \draw [->,>=latex] (2) edge[in=100,out=80,loop] node[above] {$(\Sigma\backslash \{ r \})^*$} (2);
                \end{tikzpicture}
                \caption{Automate de mod\`ele de fautes avec r\'eparations} 
    \end{figure}
            
    
    \subsection{Construction du diagnostiqueur}
    Pour construire un diagnostiqueur de l'automate $A$ avec l'automate de mod\`ele de faute $MF$, on proc\'ede de la mani\`ere suivante :
    
    \begin{enumerate}
            \item Faire le produit de l'automate $A$ avec l'automate $MF$. Un \'etat de $A\times MF$ est appel\'e un \'etat fautif si et seulement si c'est un produit d'un \'etat fautif de $MF$ avec un autre \'etat de $A$
            \item Remplacer les \'ev\`enements de $\Sigma_{no}$ par des $\varepsilon$-transitions et faire l'$\epsilon$-cl\^oture, $C = \operatorname{cl}_\varepsilon((A\times MF)[\varepsilon/f])$.
          \item D\'eterminiser l'automate $C$ avec l'algorithme des parties, on note $D$ l'automate d\'eterminis\'e. Un état de $D$ appartient à un ensemble isomorphe à $\mathcal{P}(Q)$, on dit que l'état de $D$ correspond à l'ensemble d'états de Q.
            \item Nous discriminons les diff\'erents \'etats de $D$ :
                    \begin{itemize}
                            \item  \'Etats normaux: Tous les \'etats correspondants à un ensemble d'\'etats non-fautifs.
                           \item \'Etats fautifs:  Tous les \'etats correspondants à un ensemble d'\'etats fautifs.
                            \item \'Etats de doute: Tous les \'etats correspondants à un ensemble composé à la fois d'\'etats fautifs et non-fautifs.
                    \end{itemize}  
                 
    \end{enumerate} 
     

\section{D\'ecision de la diagnosticabilit\'e en temps polynomial}

L'id\'ee de l'agorithme est qu'un automate est diagnosticable par rapport \`a un mod\`ele de fautes si et seulement si il existe des mots qui peuvent être observés qu'une faute se soit produite ou non.

\begin{itemize}
  \item $\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F)$ est le langage des observations avec fautes.
  \item $\pi_{\Sigma_o}(\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F))$ est le langage est observations des ex\'ecutions avec faute.
  \item $\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F)$ est le langage des ex\'ecutions sans faute.
  \item $\pi_{\Sigma_o}(\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F))$ est le langage des observations d'ex\'ecutions sans faute.
  \item Donc $\pi_{\Sigma_o}(\mathcal L(\mathcal A) \setminus \mathcal L(\mathcal F)) \cap \pi_{\Sigma_o}(\mathcal L (\mathcal A) \cap \mathcal L(\mathcal F))$ est le langage des observations ambiguës.
\end{itemize}
Il suffit donc de v\'erifier que ce langage ne contient que des mots de taille born\'ee, ce qui est équivalent au fait qu'il soit fini, ce qui est \'equivalent \`a l'absence de cycle accessible dans l'automate le repr\'esentant. Or on sait construire un automate de taille $|\mathcal F|^2 \times |\mathcal A|^2$ reconnaissant ce langage et la d\'etection de cycle accessible peut se faire en temps lin\'eaire. On dispose donc d'un algorithme en $|\mathcal F|^2 \times |\mathcal A|^2$ pour d\'ecider si un automate est diagnosticable par rapport \`a un mod\`ele de fautes.

Note : La longueur du mot le plus long dans ce langage est la dur\'ee maximale pendant laquelle on ne sait pas si le syst\`eme a fait une faute ou non.


\section{D\'efinitions de l'opacit\'e}

\subsection{Quelques d\'efinitions de base}

Nous allons d'abord donner quelques d\'efinitions sur le syst\`eme de transition d'\'etats \'etiquett\'e afin d'introduire les conceptions de opacit\'e.

\subsubsection{Syst\`eme de transition d'\'etats \'etiquett\'e (LTS)}

Un syst\`eme de transition d'\'etats \'etiquett\'e LTS est un quadruplet 

$$LTS = (S,L,\Delta,S_0)$$

avec
\begin{itemize}
	\item $S$ : un ensemble d'\'etats (potentiellement infini)
	\item $L$ : un ensemble de labels(potentiellement infini)
	\item $\Delta \subseteq S\times L \times S$ : une relation de transition
	\item $S_0$ : un ensemble fini non vide des \'etats initiaux 
\end{itemize}

Remarque : dans la suite nous consid\'erons que des syst\`eme de transition d'\'etats \'etiquett\'e d\'eterministe.

\subsubsection{Run}

Un $Run$ d'un LTS est un couple $(s_0,\lambda)$ avec :

\begin{itemize}
	\item $s_0 \in S_0$
	\item $\lambda = l_1 \dots l_n$ : une s\'equence finie des \'etiquettes telle qu'il existe $s_1,s_2,\dots ,s_n \in S$ tels que $\forall i \in \{1, \dots n\}, (s_{i-1},l_i,s_i) \in \Delta$ 
\end{itemize}

Notons $s_n$ par $s_0\oplus \lambda$, remarquons que dans la sous-section pr\'ec\'edente nous avons fait l'hypoth\`ese que le $LTS$ est d\'eterministe, donc $s_0\oplus \lambda$ est bien d\'efini.

L'ensemble des tous les $Run$ est not\'e par $Run(LTS)$.

Nous notons le langage g\'en\'er\'e par $LTS$ par 

$$\mathcal{L}(LTS) = \{\lambda | \exists s_0 \in S_0 \mbox{ tel que } (s_0,\lambda) \in Run(LTS)\}$$


\subsection{Observabilit\'e et opacit\'e}

Soit $LTS=(S,L,\Delta,S_0)$ est un syst\`eme de transition d'\'etats \'etiquett\'e, et $\Sigma_{obs}$ est un ensemble des \'el\'ements $observables$. Remarque nous notons que $\Sigma_{obs}^{\varepsilon} = \Sigma_{obs} \cup \{\varepsilon\}$

Nous allons maintenant mod\'eliser les diff\'erentes capacit\'es d'observation sur le syst\`eme qui est mod\'elis\'e par un LTS. Nous commen\c cons par d\'efinir les diff\'erents fonctions d'observations

\subsubsection{Diff\'erents fonctions d'observation et leur capacit\'e d'observation}

Nous d\'efinissons toutes les fonctions $\Omega : Run(LTS) \rightarrow \Sigma_{obs}^*$ comme les fonctions   
 d'observation.
 
Il y a plusieurs types de capacit\'e d'observation : 


$statique/dynamique/orwellian/m-orwellian(m\geq 1)$ :
		
Il existe une <<fonction d'observation>> sur les mots compos\'es par les \'etiquettes $\Omega_{etiq} : \Sigma^* \rightarrow \Sigma_{obs}^{\varepsilon}$ telle que 
	
	$$\forall (s,\lambda)= (s,l_1\dots l_n) \in Run(LTS), \Omega(s,\lambda) = \Omega_{etiq}(k_1)\circ\Omega_{etiq}(k_2)\circ\dots\circ\Omega_{etiq}(k_n)$$
	
	Ce sont les diff\'erents choix de $(k_1,\dots, k_n)$ qui d\'efinissent la capacit\'e d'observation.
	



\begin{itemize}
        \item Statique : $k_i = l_i$ 
	\item Dynamique : $k_i = l_1 \dots l_i$
	\item Orwellian : $k_i = \lambda$
	\item m-orwellian : $k_i = l_{max(1,i-m+1)} \dots l_{min(n,i+m-1)}$		

\end{itemize}

	Remarque : la notion $statique$ et $orwellian$ se r\'eduisent en cas particulier de $m-orwellian$, $statique$ est $1-orwellian$ et $orwellian$ est $\infty-orwellian$.

	
\subsubsection{Diff\'erents types d'Opacit\'e}

\begin{mydef}
	Soit $\Omega$ une fonction d'observation et $Secret$ un sous-ensemble de $Run(LTS)$. Nous disons que $Secret$ est opaque par rapport \`a $\Omega$ si et seulement si
	
	$$\forall (s,\lambda) \in Secret, \exists (s',\lambda')\not\in Secret \mbox{ tel que } \Omega(s,\lambda) = \Omega (s',\lambda')$$
	
	ou nous pouvons voir cette d\'efinition en terme d'ensembles :
	
	$$\Omega(Secret)\subseteq \Omega(Run(LTS)-Secret)$$
\end{mydef}

Nous pouvons aussi d\'efinir les diff\'erents niveaux d'opacit\'e comme pour les fonction d'observation. Nous disons que $Secret$ est $init-opaque/final-opaque/total-opaque$ s'il existe un sous-ensemble  $Secret'$ de l'ensemble des \'etats de $LTS$ tel que :

$$\forall (s,\lambda) \in Run(LTS), (s,lambda) \in Secret \Leftrightarrow \sigma \in Secret'$$

C'est le choix de sigma qui va d\'efinir les diff\'erents niveaux d'opacit\'e :

\begin{itemize}
	\item $initial-opaque$ : $\sigma = s$
	\item $final-opaque$ : $\sigma = s\oplus \lambda$
	\item $total-opaque$ : $\sigma = s s_1 \dots s_n \mbox{ avec } s_i = s\oplus(l_1\dots l_n)$
\end{itemize} 

\section{Non-interf\'erence}

L'id\'ee de base de la non-interf\'erence est que les labels sont soit high, soit low. Les labels low sont visibles par tout le monde alors que les labels high sont priv\'es. Un LTS est dit non-interf\'erent si il n'est pas possible de d\'etecter la pr\'esence d'un label high dans un run en observant uniquement les labels low.

\begin{mydef}
  Soit $LTS = (S,L,\Delta,S_0)$ un syst\`eme de transition d'\'etats \'etiquett\'e avec $L=L_{high}\sqcup L_{low}$. $LTS$ est non-interf\'erent ssi $\pi_{L_{low}}(L(LTS)) \subseteq L(LTS)$, c'est-\`a-dire si pour chaque run de $LTS$, le run o\`u l'on a enlev\'e tous les \'el\'ements de $L_{high}$ est encore un run.
\end{mydef}

Th : Toute propri\'et\'e d'opacit\'e initiale reposant sur une fonction d'observation statique peit se r\'eduire \`a un probl\`eme  de non-interf\'erence.

Th : Tout probl\`eme de non-interf\'erence peut se r\'eduire \`a un probl\`eme d'opacit\'e reposant sur une fonction 'dobservation statique.
\end{document}
