\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{float}
\newtheorem{myth}{Th\'eor\`eme}
\newtheorem{mydef}{D\'efinition}
\title{Diagnosticabilit\'e avec co\^ut}

\begin{document}

\section*{Introduction}

blablabla

2semaines diag rep

2 semaines diag oracle

\section{Diagnostic avec r\'eparation}
\subsection{Rappel : Définition de la diagnosticabilité}
\begin{quote}
Soit un automate fini d\'eterministe $A$ appel\'e syst\`eme, un modèle de faute qui reconnait le langage de faute $L$ et une partition $\Sigma=\Sigma_o\sqcup \Sigma_{no}$. On dira qu'un \'ev\`enement est observable (resp. non-observable) s'il est dans $\Sigma_o$ (resp. $\Sigma_{no}$).

On dit que $L$ est diagnosticable dans le système $A$~\cite{SamSRST96}  si et seulement si $$\begin{array}{l}
\exists n \in \mathbb N, \forall w \in L,\\
\forall u \in \Sigma^*, \left(\left|\pi_{\Sigma_o}(u)\right|\ge n \land wu \in \mathcal L(A)\right) \implies\\
\forall v \in \mathcal L(A), \pi_{\Sigma_o}(v)=\pi_{\Sigma_o}(wu) \implies v \in L
\end{array}$$

Intuitivement, il existe une borne $n$ telle que pour toute ex\'ecution du système produisant un mot $w$ contenant une faute, si l'on attend $n$ nouveaux observables ($u$), alors tous les mots $v$ qui produisent la m\^eme observation que $wx$ contiennent une faute, ce qui veut dire que quand une faute a eu lieu, on peut toujours affirmer sans se tromper qu'elle eu lieu (au plus tard $n$ observables après qu'elle se soit produite).
\end{quote}

\subsection{Extension : Ajout des r\'eparations}

Le mod\`ele pr\'ec\'edent ne permet de mod\'eliser que les fautes permanentes. Nous envisageons donc de d\'efinir une nouvelle diagnosticabilit\'e (que l'on appellerait $R$-diagnosticabilit\'e) qui prendrait en compte les r\'eparations. Un syst\`eme $R$-diagnosticable serait alors un syst\`eme pour lequel toutes les fautes sont d\'etect\'ees avant d'\^etre r\'epar\'ees et apr\`es un nombre born\'e d'\'ev\`enements observables. Nous chercherons \`a faire en sorte qu'un syst\`eme $R$-diagnosticable soit diagnosticable et qu'un syst\`eme diagnosticable dans lequel aucune r\'eparation ne peut avoir lieu le soit $R$-diagnosticable.

D'un point de vue technique, autoriser les r\'eparations revient \`a rel\^cher la contrainte de cl\^oture par extension ($L\Sigma^*\subseteq L$) impos\'ee au langage diagnostiqu\'e. En effet, si aucune r\'eparation n'est possible, une fois qu'une faut a eu lieu, elle ne peut pas dispara\^itre donc tous les mots partageant le m\^eme pr\'efixe sont fautifs mais lorsqu'une r\'eparation a lieu, le mot n'est pas fautif alors qu'un de ses pr\'efixes l'est puisqu'une faute a eu lieu.

Pour le moment, nous envisageons la d\'efinition suivante :

\begin{mydef}
  Une faute $f$ qui peut \^etre r\'epar\'ee par $r$ est $R$-diagnosticable sur un syst\`eme $A$ si et seulement si\\
  $\exists n \in \mathbb N,\exists Diag : \pi_o(\mathcal L(A)) \to 2^{\{tt, ff\}}\setminus \{\emptyset\}$,\\
  $\forall ufv\in \mathcal L(A)$ avec $v\in \left(\Sigma\setminus \{r\}\right)^*$,\\
  $\exists v'\le v, |\pi_o(v')| \le n \land Diag(\pi_o(ufv'))=\{tt\}$
\end{mydef}

Intuitivement, cela veut dire qu'il existe un diagnostiqueur $Diag$ qui prend une observation et dit si l'etat est sain ($\{tt\}$), fautif ($\{ff\}$) ou ambigu ($\{tt, ff\}$). On impose que ce diagnostiqueur soit capable, \'etant donn\'e une ex\'ecution ($ufvr$) contenant une faut et une r\'eparation de d\'etecter qu'une faute a effectivement eu lieu ($Diag(\pi_o(ufv'))=\{tt\}$) avant la r\'eparation (mais pas forc\'ement juste avant, n'importe quand entre la faute et la r\'eparation, d'o\`u l'utilisation de $v'$ qui est un pr\'efixe de $v$). L'existence du $n$ et la condition $|\pi_o(v')| \le n$ servent a forcer la d\'etection d'une faute non r\'epar\'ee en temps fini.

\subsection{R\'esultats envisag\'es}

Nous pensons pouvoir d\'ecider l'existence d'un tel couple $(n, Diag)$ en temps polynomial en utilisant une twin machine $A\times A$ et envisageons $A\times det(A)$ comme diagnostiqueur.

TODO ajouter pk AxA "appele twin machine". $cl_\varepsilon(A)\times det(A)$

\section{Diagnostic avec oracles et budget}
\subsection{Motivation}

En pratique, l'observation d'un système a souvent un cout. Or la diagnosticabilité binaire habituelle ne permet pas de discriminer les systèmes que l'on peut diagnostiquer pour un coût très faible de ceux pour lesquels le diagnostique est plus couteux. Nous envisageons donc de raffiner la notion de diagnosticabilit\'e afin de prendre en compte son coût.


\subsection{D\'efinition}

Pour d\'efinir les nouvelles notions, on commence par introduire un $oracle$.

\begin{mydef}{Oracle}

  Nous d\'efinissons un oracle comme \'etant une fonction $O: 2^Q\times Run \to \{True, False\} \times \mathbb{N}$, qui prend une ex\'ecution et une partition des \'etats courants possibles et renvoie une valeur bool\'eanne qui est vraie si et seulement si l'\'etat courant est dans la partition des \'etats donn\'es. Et une valeur $n \in \mathbb{N}$ qui indique le co\^ut de cette consultation.

\end{mydef}

Il apparaît clairement que si nous permettons la consultation de n'importe quel oracle infiniement souvent, alors nous allons toujours pouvoir d\'eterminer si l'\'etat courant est fautif. Nous pouvons donc consid\'erer cela comme une extension de la d\'efinition de la diagnosticabilit\'e. Parce que nous pouvons trouver des syst\`emes qui ne sont pas diagnosticables, mais en ajoutant un appel d'oracle nous arrivons le diagnostiquer. Comme l'exemple suivant:

\begin{figure}[H]
  \begin{center}
    \begin{tikzpicture}
      \node[draw,circle](0) at (-1, 0){0};
      \node[draw,rectangle](1) at (1, 0){1};
      \draw[->,>=latex] (0)->(1)node[midway,above]{$a$};
      \draw[->,>=latex] (0) edge[in=110,out=70,loop] node[above] {$a$} (0);
      \draw[->,>=latex] (1) edge[in=110,out=70,loop] node[above] {$a$} (1);
    \end{tikzpicture}
  \end{center}
\end{figure}

Dans l'exemple nous notons que les \'etats fautifs par les rectangles et les \'etat non-fautif par les cercles. Et le syst\`eme initial n'est pas diagnosticabile, mais si nous pouvons d\'eambigu\"uer entre l'\'etat $1$ et l'\'etat $2$, alors le syst\`eme devient diagnosticable.

Ensuite nous allons d\'efinir un co\^ut moyen de la consultation pour un syst\`eme $k$-diagnosticable.

\begin{mydef}{Co\^ut moyen pour les syst\`emes $k$-diagnosticables}
  
  Nous posons la sommes des co\^uts \`a payer pour les consultations des oracles normalis\'ee par $k$ comme \'etant le co\^ut moyen des syst\`emes $k$-diagnosticables.
\end{mydef}

\subsection{Questions reste \`a trouver.}

Nous avons plusieurs questions pour cette d\'efinition reste \`a r\'soudre.

\begin{itemize}
\item Nous avons d\'efini que toutes les consultations des oracles auront un co\^ut. Plusieurs questions est pos\'ees \`a ce niveau. Comment peut-on d\'efinir les diff\'erents co\^uts pour chaque consultation? Une fois nous avons d\'efinit les co\^uts de chaque consultation, comment peut-on trouver une strat\'egie pour laquelle le co\^ut de diagnostiquer est minimal.

\item Est-ce que cette notion peut \^etre d\'efini comme une propri\'et\'e en des twin-plants construits \`a partir du syst\`eme?

\item Est-ce que nous devons encore ajouter des contraintes pour les consultations des oracles? Pour la m\^eme configuration, on ne peut consulter qu'une seule fois le m\^eme oracle par exemple.

\item Nous avons envie de d\'efinir un co\^ut moyen de la consultation de l'oracle. Mais dans des cas particulier cela va d\'efinir des syst\`emes qui sont en m\^eme temps non-diagnosticable et de co\^ut moyen nul. L'exemple ci-dessous est un tel exemple:

\begin{figure}[H]
  \begin{center}
    \begin{tikzpicture}
      \node[draw,circle](0) at (-1, 0){0};
      \node[draw,rectangle](1) at (1, 0){1};
      \draw[->,>=latex] (0)->(1)node[midway,above]{$a$};
      \draw[->,>=latex] (0) edge[in=110,out=70,loop] node[above] {$a$} (0);
      \draw[->,>=latex] (1) edge[in=110,out=70,loop] node[above] {$a$} (1);
    \end{tikzpicture}
  \end{center}
\end{figure}

  
\end{itemize}


\subsection{Plan de travail}

Nous allons tra\^iter les diff\'erents probl\`emes que nous avons pos\'es pr\'ec\'edemment

\subsubsection{Cas le plus simple}

Nous commen\c cerons par un oracle sur une partitions que nous avons d\'efini avant. Donc la fonction oracle est r\'eduite \`a $O : Run \to \{True, False\}$. Nous consid\'erons que chaque consultation de l'oracle co\^ute 1. Notre but sera de trouver une strat\'egie telle que toutes les fautes sont trouv\'ees en utilisant le moins souvent possible l'oracle au plus apr\`es $k$ coups.

Donc nous avons envie d'introduire la notion de $k$-diagnosticabilit\'e pour \'eviter les syst\`eme qui sont \`a la fois non-diagnosticalbe et de co\^ut moyen nul.

\subsubsection{Cas avec les diff\'erents types d'oracles}

Dans le cas plus g\'en\'eral, nous avons envie de g\'en\'eraliser le probl\`eme que nous avons d\'efinit avant. Nous allons r\'esoudre le probl\`eme en donnant plusieurs oracles diff\'erents, et essayer de trouver la strat\'egie pour avoir un co\^ut moyen minimal pour diagnostiquer les syst\`emes $k$-diagnosticables.

\subsubsection{Extensions envisag\'ees}
Les questions de budget rechargeable sont aussi envisag\'ees. Car il nous semble naturel que nous pouvons avoir des budgets qui se charge apr\`es un nombres de coups ou ap\`es avoir passer un \'etat sp\'ecifique.

\subsection{Quelques id\'ees et des pistes pour continuer}

Il nous semble tr\`es probable qu'il faut utiliser les m\'ethodes de la th\'eorie des jeux pour trouver les strat\'egies du budget minimal.


\end{document}
