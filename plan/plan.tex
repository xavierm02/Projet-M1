\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{float}
\newtheorem{myth}{Th\'eor\`eme}
\newtheorem{mydef}{D\'efinition}
\title{Diagnosticabilit\'e avec co\^ut}

\begin{document}

\section*{Introduction}

blablabla

2semaines diag rep

2 semaines diag oracle

\section{Diagnostic avec r\'eparation}
\subsection{Rappel : Définition de la diagnosticabilité}
\begin{quote}
Soit un automate fini d\'eterministe $A$ appel\'e syst\`eme, un modèle de faute qui reconnait le langage de faute $L$ et une partition $\Sigma=\Sigma_o\sqcup \Sigma_{no}$. On dira qu'un \'ev\`enement est observable (resp. non-observable) s'il est dans $\Sigma_o$ (resp. $\Sigma_{no}$).

On dit que $L$ est diagnosticable dans le système $A$~\cite{SamSRST96}  si et seulement si $$\begin{array}{l}
\exists n \in \mathbb N, \forall w \in L,\\
\forall u \in \Sigma^*, \left(\left|\pi_{\Sigma_o}(u)\right|\ge n \land wu \in \mathcal L(A)\right) \implies\\
\forall v \in \mathcal L(A), \pi_{\Sigma_o}(v)=\pi_{\Sigma_o}(wu) \implies v \in L
\end{array}$$

Intuitivement, il existe une borne $n$ telle que pour toute ex\'ecution du système produisant un mot $w$ contenant une faute, si l'on attend $n$ nouveaux observables ($u$), alors tous les mots $v$ qui produisent la m\^eme observation que $wx$ contiennent une faute, ce qui veut dire que quand une faute a eu lieu, on peut toujours affirmer sans se tromper qu'elle eu lieu (au plus tard $n$ observables après qu'elle se soit produite).
\end{quote}

\subsection{Extension : Ajout des r\'eparations}

Le mod\`ele pr\'ec\'edent ne permet de mod\'eliser que les fautes permanentes. Nous envisageons donc de d\'efinir une nouvelle diagnosticabilit\'e (que l'on appellerait $R$-diagnosticabilit\'e) qui prendrait en compte les r\'eparations. Un syst\`eme $R$-diagnosticable serait alors un syst\`eme pour lequel toutes les fautes sont d\'etect\'ees avant d'\^etre r\'epar\'ees et apr\`es un nombre born\'e d'\'ev\`enements observables. Nous chercherons \`a faire en sorte qu'un syst\`eme $R$-diagnosticable soit diagnosticable et qu'un syst\`eme diagnosticable dans lequel aucune r\'eparation ne peut avoir lieu le soit $R$-diagnosticable.

D'un point de vue technique, autoriser les r\'eparations revient \`a rel\^cher la contrainte de cl\^oture par extension ($L\Sigma^*\subseteq L$) impos\'ee au langage diagnostiqu\'e. En effet, si aucune r\'eparation n'est possible, une fois qu'une faut a eu lieu, elle ne peut pas dispara\^itre donc tous les mots partageant le m\^eme pr\'efixe sont fautifs mais lorsqu'une r\'eparation a lieu, le mot n'est pas fautif alors qu'un de ses pr\'efixes l'est puisqu'une faute a eu lieu.

Pour le moment, nous envisageons la d\'efinition suivante :

\begin{mydef}
  Une faute $f$ qui peut \^etre r\'epar\'ee par $r$ est $R$-diagnosticable sur un syst\`eme $A$ si et seulement si\\
  $\exists n \in \mathbb N,\exists Diag : \pi_o(\mathcal L(A)) \to 2^{\{tt, ff\}}\setminus \{\emptyset\}$,\\
  $\forall ufv\in \mathcal L(A)$ avec $v\in \left(\Sigma\setminus \{r\}\right)^*$,\\
  $\exists v'\le v, |\pi_o(v')| \le n \land Diag(\pi_o(ufv'))=\{tt\}$
\end{mydef}

Intuitivement, cela veut dire qu'il existe un diagnostiqueur $Diag$ qui prend une observation et dit si l'etat est sain ($\{tt\}$), fautif ($\{ff\}$) ou ambigu ($\{tt, ff\}$). On impose que ce diagnostiqueur soit capable, \'etant donn\'e une ex\'ecution ($ufvr$) contenant une faut et une r\'eparation de d\'etecter qu'une faute a effectivement eu lieu ($Diag(\pi_o(ufv'))=\{tt\}$) avant la r\'eparation (mais pas forc\'ement juste avant, n'importe quand entre la faute et la r\'eparation, d'o\`u l'utilisation de $v'$ qui est un pr\'efixe de $v$). L'existence du $n$ et la condition $|\pi_o(v')| \le n$ servent a forcer la d\'etection d'une faute non r\'epar\'ee en temps fini.

\subsection{R\'esultats envisag\'es}

Nous pensons pouvoir d\'ecider l'existence d'un tel couple $(n, Diag)$ en temps polynomial en utilisant une twin machine $A\times A$ et envisageons $A\times det(A)$ comme diagnostiqueur.

TODO ajouter pk AxA "appele twin machine". $cl_\varepsilon(A)\times det(A)$

\section{Diagnostic avec oracles et budget}
\subsection{Motivation}

Nous avons vu deux propri\'et\'es du syst\`eme : diagnosticabilit\'e et opacit\'e. Nous nous sommes aper\c cu qu'il y a beaucoup de syst\`emes qui ne v\'erifient aucunes des deux propri\'et\'es. Donc nous envisageons \`a raffiner les notions de non-diagnosticabilit\'e en ajoutant des informations pour nous puisse d\'etecter la faute qui a eu lieu dans le syst\`eme.

\subsection{D\'efinition}

Pour d\'efinir les nouvelles notions, nous d\'efinissons d'abord un $oracle$.

\begin{mydef}{Oracle}

  Nous d\'efinissons un oracle comme \'etant une fonction $O: 2^Q\times Run \to \{True, False\} \times \mathbb{N}$, qui prend une ex\'ecution et une partition des \'etats courants possibles et renvoie une valeur bool\'eanne qui est vraie si et seulement si l'\'etat courant est dans la partition des \'etats donn\'ee. Et une valeur $n \in \mathbb{N}$ qui indique le co\^ut de cette consultation.

\end{mydef}

C'est clair que si nous permettons les consultations de ces oracles infiniement souvent, alors nous allons pouvoir d\'eterminer que si l'\'etat courant est fautif. Nous pouvons donc consid\'erer cela comme une extension de la d\'efinition de la diagnosticabilit\'e. Parce que nous pouvons trouver des syst\`emes qui ne sont pas diagnosticables, mais en ajoutant un appel d'oracle nous arrivons le diagnostiquer. Comme l'exemple suivant:

\begin{figure}[H]
  \begin{center}
    \begin{tikzpicture}
      \node[draw,circle](0) at (-1, 0){0};
      \node[draw,rectangle](1) at (1, 0){1};
      \draw[->,>=latex] (0)->(1)node[midway,above]{$a$};
      \draw[->,>=latex] (0) edge[in=110,out=70,loop] node[above] {$a$} (0);
      \draw[->,>=latex] (1) edge[in=110,out=70,loop] node[above] {$a$} (1);
    \end{tikzpicture}
  \end{center}
\end{figure}

Dans l'exemple nous notons que les \'etats fautifs par les rectangles et les \'etat non-fautif par les cercles.

Ensuite nous avons d\'efini un co\^ut moyen de la consultation pour un syst\`eme $k$-diagnosticable.

\begin{mydef}{Co\^ut moyen pour les syst\`emes $k$-diagnosticables}
  
  Nous posons la sommes des co\^ut \`a payer pour les consultations des oracles normalis\'ee par $k$ comme \'etant le co\^ut moyen des syst\`emes $k$-diagnosticables.
\end{mydef}

\subsection{Questions reste \`a trouver.}

Nous avons plusieurs questions pour cette d\'efinition reste \`a r\'soudre.
kk
\begin{itemize}
\item Nous avons d\'efini que toutes les consultations des oracles auront un co\^ut. Plusieurs questions est pos\'ees \`a ce niveau. Comment peut-on d\'efinir les diff\'erents co\^uts pour chaque consultation? Une fois nous avons d\'efinit les co\^uts de chaque consultation, comment peut-on trouv\'e une strat\'egie pour la quelle le co\^ut de la diagnostication est minimal.

\item Est-ce que cette notion peut \^etre d\'efini comme une propri\'et\'e en utilisant les twin-plant?

\item Est-ce que nous devons encore ajouter des contraintes pour les consultations des oracles? Pour la m\^eme configuration, on ne peut consulter qu'une seule fois le m\^eme oracle par exemple.

\item Nous avons envie de d\'efinir un co\^ut moyen de la consultation de l'oracle. Mais dans des cas particulier cela va d\'efinir des syst\`eme non-diagnosticable mais de co\^ut moyen nul. L'exemple ci-dessous est un tel exemple:

\begin{figure}[H]
  \begin{center}
    \begin{tikzpicture}
      \node[draw,circle](0) at (-1, 0){0};
      \node[draw,rectangle](1) at (1, 0){1};
      \draw[->,>=latex] (0)->(1)node[midway,above]{$a$};
      \draw[->,>=latex] (0) edge[in=110,out=70,loop] node[above] {$a$} (0);
      \draw[->,>=latex] (1) edge[in=110,out=70,loop] node[above] {$a$} (1);
    \end{tikzpicture}
  \end{center}
\end{figure}

  
\end{itemize}


\subsection{Plan de travail}

Nous allons tra\^iter les diff\'erents probl\`emes que nous avons pos\'e avant

\subsubsection{Cas le plus simple}

Nous commen\c cerons par un oracle sur une partitions que nous avons d\'efini avant. Donc la fonction oracle est r\'eduite \`a $O : Run \to \{True, False\}$. Nous consid\'erons que chaque consultation de l'oracle co\^ute 1. Notre but sera de trouver une strat\'egie pour trouver toutes fautes en utilisant le moins souvent possible l'oracle au plus apr\`es $k$ coup.

Donc nous avons envie d'introduire la notion de $k$-diagnosticabilit\'e pour eviter les probl\`emes de co\^ut moyenne nulle.

\subsubsection{Cas avec les diff\'erents types d'oracles}

Dans le cas plus g\'en\'eral, nous avons envie de g\'en\'eraliser le probl\`eme que nous avons d\'efinit avant. Nous allons r\'esoudre le probl\`eme en donnant plusieurs oracles diff\'erents, et essayer de trouver la strat\'egie pour avoir un co\^ut moyen minimal pour les syst\`emes $k$-diagnosticables.

\subsubsection{Extensions envisag\'ees}
Les questions de budget rechargeable sont aussi envisag\'ees. Car il nous semble naturel que nous pouvons avoir des budget qui se charge tous les combiens de co\^ut ou ap\`es avoir passer un \'etat sp\'ecifique.

\subsection{Quelques id\'ees et des pistes pour continuer}

Il nous semble tr\`es probables qu'il faut utiliser les m\'ethode de la th\'eorie de jeux pour trouver les strat\'egie du budget minimal.


\end{document}
